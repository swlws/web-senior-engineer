# CA 之后的动作

实际上就是 HTTPS（TLS 握手） 的核心流程。

## 🌐 一、前提：浏览器为什么能拿到服务端公钥？

当你访问一个 HTTPS 网站时，浏览器与服务器首先进行 TLS 握手（TLS Handshake）。
在这个过程中，服务器会把自己的 数字证书（Certificate） 发给浏览器。

证书中包含：

- 服务器的 RSA / ECDSA 公钥
- 证书的签发者（CA 信息）
- 域名、有效期
- CA 的签名（保证真实性）

## 🧩 二、浏览器拿到公钥后的动作（详细流程）

以下以 RSA 握手为例（TLS 1.2 为简化理解）：

### 🔹 Step 1：验证证书是否合法

浏览器首先会验证：

1. 证书链完整性：由受信任 CA 签发；
2. 证书有效期：在有效时间范围内；
3. 域名匹配：证书内的域名与当前访问的域名一致；
4. 签名校验：用 CA 的公钥验证证书签名是否正确。

✅ 验证通过后，浏览器确认：

> 这个公钥确实是你服务器的，并且没有被篡改。

### 🔹 Step 2：生成随机对称密钥（Pre-Master Secret）

验证完证书后，浏览器会生成一个随机数（称为 Pre-Master Secret），这是接下来真正用于加密通信的基础密钥。

### 🔹 Step 3：使用公钥加密随机密钥

浏览器使用服务端证书中的 公钥 加密这个 Pre-Master Secret，然后发送给服务器：

```ini
encryptedSecret = Encrypt(publicKey, preMasterSecret)
```

### 🔹 Step 4：服务器使用私钥解密

服务器收到密文后，使用自己的 私钥 解密出原始的 Pre-Master Secret：

```ini
preMasterSecret = Decrypt(privateKey, encryptedSecret)
```

### 🔹 Step 5：双方生成会话密钥（Session Key）

接下来浏览器和服务器会各自根据 Pre-Master Secret 计算出相同的 对称会话密钥（Session Key），
通常使用一个`密钥派生函数`（Key Derivation Function, KDF）：

```ini
sessionKey = KDF(preMasterSecret, clientRandom, serverRandom)
```

### 🔹 Step 6：建立加密通道（对称加密）

之后的通信全部使用 对称加密算法（如 AES-GCM） 来进行：

- 浏览器使用 sessionKey 加密请求；
- 服务器使用 sessionKey 解密请求；
- 双方通信加密效率高、安全性强。

## ⚙️ 三、TLS 1.3 的改进

在 TLS 1.3 中，流程更高效：

- 不再直接传输 Pre-Master Secret；
- 使用 ECDHE（椭圆曲线 Diffie-Hellman） 实现 前向保密（PFS）；
- 减少握手轮数（从 2RTT → 1RTT，甚至 0RTT）。

## 🔒 四、总结流程图（RSA 握手简化版）

```txt
浏览器（Client）                          服务器（Server）
────────────────────────────────────────────────────────────
1. 发送 ClientHello
                                                
                               2. 返回 ServerHello + 证书（含公钥）
────────────────────────────────────────────────────────────
3. 验证证书合法性（CA、公钥、域名、有效期）

4. 生成随机 Pre-Master Secret
   ↓
   使用服务器公钥加密后发送
────────────────────────────────────────────────────────────
                                 5. 使用私钥解密出 Pre-Master Secret
────────────────────────────────────────────────────────────
6. 双方计算出相同的 Session Key
────────────────────────────────────────────────────────────
7. 后续通信全部使用对称加密（AES-GCM / ChaCha20）
```

## ✅ 总结一句话

浏览器拿到服务器的公钥后，不会直接用它加密数据，而是：

- 验证它是否可信（CA 签名）；
- 用它加密一个随机密钥（Pre-Master Secret）；
- 然后双方用该密钥生成对称 Session Key；
- 之后的所有通信都用对称加密完成。
