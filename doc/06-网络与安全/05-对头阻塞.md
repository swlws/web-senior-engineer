# 对头阻塞

“对头阻塞”（Head-of-Line Blocking，HOL Blocking）是一种性能瓶颈现象，广泛出现在网络协议中。它指的是：

> 因为队列前面的一个请求阻塞了后面的请求，导致整个队列都无法向前推进。

这个问题会出现在多个层级，比如 HTTP 层 和 TCP 层。

## 🔹 一、HTTP 层面的对头阻塞（以 HTTP/1.1 为例）

### 📌 场景举例

在 HTTP/1.1 中，即使你通过「长连接（Keep-Alive）」发出多个请求，**这些请求必须排队，一个一个处理：**

```text
Client              Server
  | --- 请求 A --->   |
  | <--- 响应 A ---   |
  | --- 请求 B --->   |
  | <--- 响应 B ---   |
```

如果 **请求 A 的响应很慢**，那即使 B 是个轻量请求，也得等 A 响应完才能进行，**B 被 A 阻塞** —— 这就是 **HTTP 层的 HOL Blocking**。

## 🔹 二、TCP 层面的对头阻塞（HTTP/2 遇到的新问题）

### 🧩 多路复用仍在一条 TCP 连接上

在 HTTP/2 中，引入了多路复用，允许多个请求同时共享一个连接。但是，这些数据帧最终都要通过一个 TCP 流 发送。

问题出现了：

- 如果 TCP 传输过程丢了一个包
- TCP 必须 重传该包，并且 不能交付后续数据帧给应用层
- 所有 HTTP/2 请求都被“堵在”这个丢包点后面

这就是 TCP 层的 HOL Blocking —— 即使是不同的请求，只因共用一个 TCP 流，依然会“排队等包”。

## 🔹 三、QUIC / HTTP/3 如何解决

HTTP/3 使用基于 UDP 的 QUIC 协议，完全解决了 TCP 层的对头阻塞：

- QUIC 将数据划分成多个“独立流（streams）”
- 每个流在 UDP 上独立传输，一个流丢包不影响其他流
- 所以即使一个响应丢包，也不会影响其他响应

**💡 总结一句话：**

> QUIC 把“多车一条道”变成了“多车多车道”，互不影响。

## ✅ 总结对比

| 协议层 | 协议            | 是否存在对头阻塞 | 描述                 |
| --- | ------------- | -------- | ------------------ |
| 应用层 | HTTP/1.1      | ✅ 是      | 请求需串行处理，前一个慢，后一个卡住 |
| 应用层 | HTTP/2        | ❌（已解决）   | 应用层多路复用，避免请求串行     |
| 传输层 | HTTP/2 + TCP  | ✅ 是      | TCP 丢包时所有流都被阻塞     |
| 传输层 | HTTP/3 + QUIC | ❌（已解决）   | 每个流独立，不互相影响        |
