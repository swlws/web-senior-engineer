# 低代码

## 🧠 一句话总结低代码核心理念：

> 抽象通用开发能力 → 以图形化/配置化方式封装 → 让更多人更快地构建高质量应用。

## 🎯 核心理念要点拆解：

### 1. 抽象能力封装

- 将常见开发任务（如表单渲染、CRUD 操作、权限控制、流程引擎等）进行组件化、模块化封装。
- 通过“拖拉拽 + 配置”方式复用已有能力，而非手写逻辑。

### 2. 开发门槛降低

- 不再需要精通前后端开发。
- 业务人员、产品经理也能参与开发（公民开发者 Citizen Developer）。

### 3. 敏捷开发 & 快速迭代

- 支持业务快速上线、低成本验证、低风险试错。
- 改变传统开发中前端、后端、测试、运维长周期协作模式。

### 4. 标准化 + 可扩展

- 核心为一套“标准的页面结构 + 数据模型 + 流程逻辑”。
- 支持可插拔，可自定义代码扩展（如 JS 脚本、DSL、动态组件等）。

### 5. 统一技术栈与治理

- 一套开发平台 + 统一的中后台 UI 体系 + 数据服务平台。
- 降低系统碎片化，便于版本管理、权限管理、监控治理。

## 🧩 举例说明：

例如一个表单系统：

- 用低代码方式，仅需拖拽组件（输入框、下拉框、校验规则），再绑定一个接口，即可生成一个完整表单页面。
- 传统方式则需：
  - 设计 UI、写 Vue/React 页面
  - 对接后端接口、处理状态、编写校验逻辑

## 🏗️ 底层支撑技术（常见实现）：

| 方向   | 示例                                 |
| ------ | ------------------------------------ |
| 视图层 | 可视化拖拽引擎（如 schema 驱动渲染） |
| 数据层 | 通用 API 代理、数据模型配置          |
| 逻辑层 | 逻辑编排器、流程引擎、JS 脚本嵌入    |
| 渲染层 | 动态组件加载、runtime schema 渲染    |
| 扩展性 | 插件机制、低代码 + pro-code 混合开发 |

## ✅ 低代码 vs 传统开发对比：

| 项目     | 传统开发   | 低代码平台        |
| -------- | ---------- | ----------------- |
| 开发者   | 专业程序员 | 程序员 + 业务人员 |
| 产出周期 | 周/天      | 小时/分钟         |
| 复用程度 | 手动复用   | 拖拽式复用组件    |
| 维护成本 | 高         | 中/低             |
| 扩展能力 | 强         | 取决于平台设计    |
| 技术门槛 | 高         | 中低              |

## 🚧 一览：低代码的主要局限性

| 类型                    | 描述                                                                                  |
| ----------------------- | ------------------------------------------------------------------------------------- |
| 🔧 可扩展性限制         | 复杂业务场景下，平台内置组件/流程无法满足需求，需频繁“逃逸”写代码，降低低代码本身价值 |
| 🔍 灵活性不足           | 对 UI 样式、交互行为、动画、定制组件等支持有限，不能完全还原设计稿或用户预期          |
| 🔒 技术锁定（平台依赖） | 绑定特定平台或 DSL，迁移困难、成本高（**Vendor Lock-in**）                            |
| 🧩 项目可维护性         | 页面、数据、逻辑都通过 GUI 配置，缺乏统一代码结构，难以版本控制、多人协作             |
| ⚠️ 性能问题             | 通用平台抽象较多，运行时渲染效率低于原生代码；复杂页面加载慢                          |
| 🔐 安全风险             | 动态执行脚本、低门槛使用 API，容易引发注入、权限越权、数据泄露等问题                  |
| 📉 开发者体验           | 对高级开发者来说 GUI 开发效率反而不高，不如直接写代码清晰可控                         |
| 🔄 流程耦合性强         | 流程编排器、表单系统强依赖平台机制，导致业务逻辑难复用、难测试                        |
| 📦 第三方生态集成       | 与主流框架/库集成不便，如复杂图表库、3D 库、视频播放器等组件接入成本高                |
| 💼 复杂协作困难         | 配置存储在数据库或 schema 中，不适合多人 Git 协作、代码审查、CI/CD                    |

## 🧭 示例说明（结合真实使用）：

### 1. 功能限制

> 业务需求需要一个「表单动态联动 + 条件渲染 + 异步校验」逻辑，低代码平台只能配置基础规则，最终必须写一段 JS 插槽，复杂逻辑全靠 eval 脚本撑着。

### 2. 平台绑定

> 使用某大型低代码平台开发大量页面后，想迁移到另一个平台或自行维护，发现无法导出标准源码，重构成本极高。

### 3. 协作困难

> 表单、流程配置保存在数据库中，难以通过 Git 管理，无法做 Pull Request、Review、分支对比。

## 🧩 适合与不适合的场景对比：

| 场景                                 | 适合低代码 | 不适合低代码            |
| ------------------------------------ | ---------- | ----------------------- |
| 通用后台系统（表单、表格、流程）     | ✅         |                         |
| CRUD 工具类系统                      | ✅         |                         |
| 定制化强的营销活动页                 |            | ❌ 动效、样式复杂       |
| 高性能图表/大屏渲染                  |            | ❌ 性能要求高           |
| 复杂交互（如画布、拖拽、可视编辑器） |            | ❌ 高交互自由度         |
| 长期维护的核心业务系统               |            | ❌ 可维护性、版本管理弱 |

## ✅ 总结建议：

低代码适合：

- 快速构建原型、PoC 项目
- 通用中后台管理系统（CMS、审批流、表单系统）
- 辅助工具、内部系统、低频迭代业务

不适合：

- 高度定制化的前端产品
- 对渲染性能、交互体验要求极高的页面
- 强协作、高测试覆盖、自动化要求的项目
