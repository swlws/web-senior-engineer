# 适配器模式

> 适配器模式 = 转换接口，让不兼容的对象也能一起工作。

典型使用场景

- 旧系统与新系统兼容（版本升级）
- 统一不同库/模块的接口
- 复用第三方组件（但其接口与现有代码不符）

## 🔧 模式结构

| 角色                | 说明                        |
| ----------------- | ------------------------- |
| **Target（目标接口）**  | 客户端期望使用的接口                |
| **Adaptee（被适配者）** | 现有的不兼容接口                  |
| **Adapter（适配器）**  | 连接两者，将 Adaptee 转换为 Target |

## 💡 示例一：类适配器（传统思路）

```js
// 被适配者：老接口
class OldLogger {
  log(message) {
    console.log('旧日志系统：', message);
  }
}

// 新接口（客户端期望的接口）
class NewLogger {
  info(message) {}
}

// 适配器
class LoggerAdapter extends NewLogger {
  constructor() {
    super();
    this.oldLogger = new OldLogger();
  }

  info(message) {
    this.oldLogger.log(message);
  }
}

// 使用
const logger = new LoggerAdapter();
logger.info('系统启动成功'); // 输出：旧日志系统： 系统启动成功
```

适配器把旧系统的 log() 接口转换成新系统的 info() 接口。

## 💡 示例二：对象适配器（更常见、灵活）

```js
class OldApi {
  request(data) {
    console.log('旧API接收：', data);
  }
}

class NewApi {
  send(data) {
    console.log('新API发送：', data);
  }
}

// 适配器
class ApiAdapter {
  constructor(oldApi) {
    this.oldApi = oldApi;
  }

  send(data) {
    // 将新接口的调用，转为旧接口逻辑
    this.oldApi.request(data);
  }
}

// 使用
const adapter = new ApiAdapter(new OldApi());
adapter.send({ user: 'Alice' }); // 输出：旧API接收： { user: 'Alice' }
```

## 💡 示例三：前端常见实际应用（统一接口返回格式）

比如不同后端接口返回格式不一致：

```js
// 返回结构 A
const responseA = { code: 0, data: { name: 'Alice' } };
// 返回结构 B
const responseB = { status: 200, result: { name: 'Bob' } };
```

我们可以写一个 适配层 来统一：

```js
function apiAdapter(response) {
  if ('code' in response) {
    return { success: response.code === 0, data: response.data };
  } else if ('status' in response) {
    return { success: response.status === 200, data: response.result };
  }
  return { success: false, data: null };
}

// 使用
console.log(apiAdapter(responseA)); // { success: true, data: { name: 'Alice' } }
console.log(apiAdapter(responseB)); // { success: true, data: { name: 'Bob' } }
```

## 💡 示例四：第三方库兼容（真实项目常见）

比如我们项目使用自己的 fetchJSON() 方法，但需要兼容 axios：

```js
// 自有接口
function fetchJSON(url, options) {
  console.log('内部 fetchJSON 请求:', url);
  return fetch(url, options).then((res) => res.json());
}

// 适配 axios，让 axios 看起来像 fetch
function axiosAdapter(axiosInstance) {
  return (url, options) => {
    return axiosInstance({
      url,
      method: options?.method || 'GET',
      data: options?.body,
      headers: options?.headers
    }).then((res) => res.data);
  };
}

// 使用
import axios from 'axios';
const fetchLike = axiosAdapter(axios);
fetchLike('/api/user', { method: 'POST', body: { name: 'Alice' } });
```

## ✅ 优缺点总结

| 优点           | 缺点              |
| ------------ | --------------- |
| 复用旧代码，兼容不同系统 | 增加中间层，略微复杂      |
| 提高系统灵活性、可维护性 | 可能引入性能开销（函数包装）  |
| 符合开闭原则（OCP）  | 若接口差异太大，适配代码会膨胀 |

## 📘 常见使用场景

| 场景       | 示例                              |
| -------- | ------------------------------- |
| 接口兼容     | 老系统升级，新旧接口不一致                   |
| 第三方库统一封装 | axios / fetch / wx.request 统一调用 |
| 数据格式适配   | 后端不同版本接口数据格式不一致                 |
| 组件库迁移    | Vue2 → Vue3，React18 → 19 等      |
| 前后端协议调整  | JSON → GraphQL、REST → RPC       |
