# 观察者与发布订阅模式

## 1. 观察者模式（Observer）

核心思想：
对象之间是 一对多依赖，目标对象（Subject） 状态变化后，会主动通知所有依赖它的 观察者（Observer）。

特点：

- 观察者直接订阅目标对象。
- 目标对象知道有哪些观察者（直接持有引用）。
- 通知是由目标对象直接发出的。

示例（伪代码）：

```js
// 被观察者
class Subject {
  constructor() {
    this.observers = [];
  }
  add(observer) {
    this.observers.push(observer);
  }
  notify(data) {
    this.observers.forEach((o) => o.update(data));
  }
}

// 观察者
class Observer {
  update(data) {
    console.log("收到通知：", data);
  }
}

const subject = new Subject();
const observer1 = new Observer();
subject.add(observer1);
subject.notify("状态变化了");
```

👉 耦合点：Subject 知道 Observer 的存在。

## 2. 发布-订阅模式（Pub-Sub）

核心思想：
引入一个 事件中心（Event Bus / Broker），发布者和订阅者通过它进行通信，彼此不直接感知。

特点：

- 发布者只管 发布消息 到事件中心。
- 订阅者只管 订阅消息，由事件中心转发。
- 发布者和订阅者完全解耦。

示例（伪代码）：

```js
class EventBus {
  constructor() {
    this.events = {};
  }
  subscribe(event, callback) {
    (this.events[event] ||= []).push(callback);
  }
  publish(event, data) {
    (this.events[event] || []).forEach((cb) => cb(data));
  }
}

const bus = new EventBus();

// 订阅者
bus.subscribe("update", (data) => console.log("订阅者收到:", data));

// 发布者
bus.publish("update", "数据更新了");
```

👉 发布者和订阅者互相不知道对方的存在，耦合度更低。

## 3. 关键差异对比

| 维度     | 观察者模式                      | 发布-订阅模式                                |
| -------- | ------------------------------- | -------------------------------------------- |
| 关系     | 目标对象 ↔ 观察者（直接依赖）   | 发布者 ↔ 事件中心 ↔ 订阅者                   |
| 耦合度   | 较高（目标需维护观察者列表）    | 较低（中间件解耦）                           |
| 通知方式 | 目标对象主动调用观察者方法      | 事件中心分发消息                             |
| 使用场景 | Vue2 的响应式系统、DOM 事件监听 | Node.js EventEmitter、消息队列、Vue EventBus |

## 4. 总结

- 观察者模式：点对点通知，目标对象直接管理和通知观察者。
- 发布-订阅模式：通过第三方事件中心解耦，常用于更复杂的多对多通信。
