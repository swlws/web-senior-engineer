# JS 执行与 DOM 渲染

✅ JS 执行会阻塞 DOM 渲染（大多数情况会）

原因是：JS 主线程和渲染流程（样式计算、布局、绘制）都在同一个线程——渲染主线程（Main Thread）上执行。

主线程没空 → 浏览器无法执行下一次渲染 → 渲染被阻塞。

## 🔥 为什么 JS 会阻塞渲染？

渲染流程包括：

- Style Calculation（样式计算）
- Layout（布局）
- Paint（绘制）
- Composite（合成）

而 JS 引擎（V8）也运行在同一个主线程上。

> 同一时刻只有一个任务能执行，要么 JS，要么布局/绘制。

只要 JS 的任务在执行：

- 渲染不会发生
- 浏览器也不会更新页面
- 帧不会产生，FPS 可能掉到 0

这就是常见的 卡顿、掉帧、JS 把 UI 卡死 的根源。

## ⚠️ 哪些情况属于“JS 阻塞渲染”？

### ✔ 长时间同步 JS

```js
for (let i = 0; i < 2e9; i++) {}
```

这段 JS 执行期间：

- DOM 修改不会立刻渲染
- 动画停止
- CSS transition 中断
- 页面“假死”

### ✔ 连续 DOM 操作阻塞渲染

如果 JS 连续执行：

```js
el.style.width = "100px";
el.style.width = "200px";
el.style.width = "300px";
```

浏览器为了优化，会延迟 layout，但只要 JS 还没结束，浏览器也不会开始渲染。

### ✔ 同步任务队列占满（大量事件处理）

例如点击事件中执行重任务，渲染也会延后。

## ❗ 但是 —— 有几个例外情况（可能不阻塞）

有三类操作 不依赖主线程 或能“逃离主线程”，因此不会被 JS 阻塞：

### 🌈 例外 1：CSS transform + opacity 动画（合成线程执行）

```css
.box {
  transition: transform 1s;
}
```

transform/opacity 动画由 合成线程（Compositor Thread） 执行，而非主线程。

即使 JS 卡死，动画仍然继续（常见于页面卡顿时仍能看到元素滑动）。

### 🌈 例外 2：Compositor-driven scrolling（合成线程滚动）

现代浏览器的滚动是在 合成线程 完成的，不靠主线程：

- 即使 JS 正忙，滚动仍然流畅（只要不触发 scroll 事件）

⚠️ 但 scroll 事件回调依然在主线程，因此会延迟。

### 🌈 例外 3：DOM 在下一帧渲染前 JS 停止了

如果 JS 执行结束时间 < 下一个 vsync（16.6ms），用户看不到阻塞。

例如：

```js
button.onclick = () => {
  for (let i = 0; i < 200000; i++); // <16ms
}
```

这种短任务一般不影响渲染。

### 🧠 浏览器的真实逻辑（非常重要）

浏览器在一帧内流程是：

```txt
JS 任务执行
    ↓
Style/Layout
    ↓
Composite
    ↓
下一帧
```

## ✔ 最终结论（适用于前端工程师）

- 1️⃣ JS 执行会阻塞 DOM 渲染，因为都在主线程。
- 2️⃣ 但 transform/opacity 动画 & 滚动 在合成线程上，不会被阻塞。
- 3️⃣ 短任务不会卡，因为没超过 1 帧的预算（16ms）。
- 4️⃣ 任何长同步 JS 都会卡住页面。
