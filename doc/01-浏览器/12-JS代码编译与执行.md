# JS 代码编译与执行

从浏览器层、JS 引擎层（以 V8 为例）到 CPU 层，尽量详细且按顺序说明。

## 一、JS 执行流程总览

```txt
JS 源代码
   │
   ▼
解析阶段（Parsing / Lexing）
   │
   ▼
抽象语法树（AST）
   │
   ▼
字节码生成 / 解释执行（Interpreter / Ignition）
   │
   ▼
热点分析（Profiler / Hot Path）
   │
   ▼
即时编译（JIT / Turbofan）
   │
   ▼
机器码执行（Native Code）
   │
   ├─ 类型变化 / 假设失败 → 去优化（Deoptimization）
   └─ 正常 → 高速执行
```

## 二、详细阶段解析

### 1️⃣ 解析阶段（Parsing / Lexing）

- 词法分析（Lexing）
  - 将 JS 源码字符串拆成 Token（关键字、变量、运算符等）
- 语法分析（Parsing）
  - Token → AST（抽象语法树）
  - AST 描述了 JS 语法结构、作用域链、函数声明等

浏览器示例：Chrome/Chromium 调用 V8 的 Parser::Parse。

### 2️⃣ 解释执行（Interpreter / Ignition）

- V8 将 AST 编译成 字节码（Bytecode）
- 字节码在 虚拟机中逐条解释执行
- 优点：
  - 启动快
  - 内存占用低
- 缺点：
  - 执行慢（循环和函数调用频繁时瓶颈明显）

### 3️⃣ 热点分析（Profiler / Hot Path）

- JS 是动态语言，类型多变
- V8 内置 执行计数器：
  - 每次函数或循环执行，计数器 +1
  - 达到阈值 → 标记为 “热点函数 / 热路径”

### 4️⃣ 即时编译（JIT / Turbofan）

- 热点代码触发 Turbofan JIT 编译
- 步骤：
  1. 字节码 → 中间表示（IR, Intermediate Representation）
  2. 类型推导：确定变量类型，优化操作
  3. 内联缓存（Inline Cache）：优化属性访问、函数调用
  4. 输出 机器码
- 下一次执行直接执行本地机器码 → 高性能

### 5️⃣ 优化与去优化（Deoptimization）

- 优化假设：
  - 对象结构固定
  - 类型不变
- 如果假设失败：
  - 回退到字节码解释执行
  - 再重新触发 JIT 编译
- 保证 动态语言安全性 + 高性能 的平衡

### 6️⃣ 执行微任务 / 宏任务（浏览器层）

- 在主线程执行 JS 的过程中，事件循环调度：
  - 宏任务（MacroTask）：setTimeout, setInterval, DOM 事件, IO 回调
  - 微任务（MicroTask）：Promise.then, queueMicrotask, MutationObserver
- V8 执行 JS → 微任务队列 → 回到宏任务 → 渲染 → 下一轮事件循环

### 7️⃣ 渲染相关（浏览器层）

- JS 执行可能修改 DOM / CSSOM
- 浏览器渲染流水线：
  1. Style → 计算样式
  2. Layout → 布局计算
  3. Paint / Rasterization → 绘制位图
  4. Composite → 合成层，最终显示
- 主线程忙时，渲染会被阻塞（除 transform/opacity 等合成线程动画）

## 三、执行链条示意（结合浏览器 + JS 引擎）

```txt
JS 源代码
   │
   ▼ 解析
AST（抽象语法树）
   │
   ▼ 字节码生成
Interpreter（Ignition）解释执行
   │
   ▼ 热点分析
Profiler 统计执行频率
   │
   ▼ JIT 编译
Turbofan → Native Machine Code
   │
   ├─ 类型变化 → 去优化 → 回到 Interpreter
   └─ 执行优化代码
   │
   ▼ 主线程
宏任务/微任务调度
   │
   ▼ DOM/CSS 修改 → 渲染
   │
   ▼ 合成 GPU 层 → 显示
```

## 四、V8 优化特点总结

- 分阶段执行：先解释，后 JIT 编译
- 热点函数触发优化：减少冷路径浪费
- 内联缓存 + 类型推导：加速动态访问
- 去优化机制：保证动态语言安全性
- 字节码 + JIT + Native 码混合执行：平衡启动速度和运行速度
