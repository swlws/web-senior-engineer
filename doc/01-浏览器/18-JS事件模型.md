# JS 事件模型

包含事件流、事件委托、捕获/冒泡、合成事件、微任务关联等

## 1. 基础：事件模型的 3 个阶段（Event Flow）

W3C DOM2 Events 定义：

1. 捕获阶段（Capturing Phase）
   事件从 window → document → html → body → … → target 父节点依次向下传播。
2. 目标阶段（Target Phase）
   到达目标节点，如果该节点绑定了捕获/冒泡事件，都可能执行。
3. 冒泡阶段（Bubbling Phase）
   从 target → … → body → html → document → window 逐级向上传播。

```txt
window
  ↓ (capture)
document
  ↓
html
  ↓
body
  ↓
div#parent
  ↓
button#child  ← target
  ↑
div#parent
  ↑ (bubble)
body
  ↑
html
  ↑
document
  ↑
window
```

## 2. 事件监听方式

### 2.1 addEventListener

```js
element.addEventListener(type, listener, options);
```

options 四个关键参数：

| 参数      | 作用                                              |
| --------- | ------------------------------------------------- |
| `capture` | 是否在捕获阶段执行                                |
| `once`    | listener 执行一次后移除                           |
| `passive` | 表示 listener 不会调用 preventDefault（性能优化） |
| `signal`  | 用于取消事件监听，与 AbortController 结合使用     |

### 3. 事件冒泡 / 捕获的实际执行顺序

示例：

```js
div.addEventListener("click", () => console.log("div capture"), true);
div.addEventListener("click", () => console.log("div bubble"));

btn.addEventListener("click", () => console.log("btn"), false);
```

执行顺序：

```txt
div capture
btn
div bubble
```

规则：

- 捕获阶段：从外到内
- 目标阶段：先执行 capture，再执行 bubbling
- 冒泡阶段：从内到外

## 4. 阻止事件传播

### 4.1 阻止事件冒泡

```js
event.stopPropagation();
```

### 4.2 阻止事件在同一节点上的其他 listener 执行

```js
event.stopImmediatePropagation();
```

常用于防止其他第三方库插入的 listener 执行。

### 4.3 阻止默认行为

```js
event.preventDefault();
```

> 注意：如果 listener 是 passive，则不能 preventDefault。

## 5. 事件委托（Event Delegation）

事件冒泡 + 事件目标一致性，可通过父节点监听子元素的事件来降低监听器数量、提升性能。

```js
document.body.addEventListener("click", (e) => {
  if (e.target.matches(".btn")) {
    // 仅 .btn 点击触发
  }
});
```

优点：

- 更少的 listener 实例 → 内存小
- 动态元素（append/remove）无需重新绑定事件
- 减少重绘/回流压力

## 6. 事件对象 (Event)

常用属性：

| 属性            | 说明                         |
| --------------- | ---------------------------- |
| `target`        | 实际触发事件的元素           |
| `currentTarget` | 当前正在执行 listener 的元素 |
| `eventPhase`    | 1：捕获，2：目标，3：冒泡    |
| `timeStamp`     | 微秒时间戳                   |
| `relatedTarget` | mouseover/out 时的相关元素   |

> 关键点：target 永远指向触发事件的最深节点，currentTarget 随事件传播而改变。

## 7. 事件是同步触发的（与微任务关系）

事件回调是主线程执行的同步宏任务。

触发顺序：

```txt
事件回调
  ↓
事件回调里的 Promise.then（微任务）
  ↓
下一个宏任务
```

示例：

```js
btn.onclick = () => {
  console.log(1);
  Promise.resolve().then(() => console.log(2));
  console.log(3);
};
```

执行顺序：

```txt
1
3
2
```

## 8. 事件触发顺序：多个事件的优先级

- 用户输入事件（click）
- microtask（Promise）
- requestAnimationFrame
- render / layout
- idle callback

## 9. 浏览器原生事件 vs React 合成事件

### React 的事件机制核心：

1. React 在根节点（如 document）注册统一的事件监听器（事件委托）。
2. 所有组件内绑定的事件是合成事件（SyntheticEvent）。
3. 合成事件会统一走 React 事件系统 → fiber → 对应组件。

优点：

- 跨浏览器兼容
- 统一事件队列
- 避免频繁 DOM 绑定

React 17 后事件委托从 document 改为 root container，避免一些权重冲突。

## 10. 特殊事件模型补充

### 10.1 focus / blur 不能冒泡

但有对等事件：

- focus → focusin（可冒泡）
- blur → focusout（可冒泡）

### 10.2 scroll 不冒泡

但能改用捕获：

```js
container.addEventListener("scroll", handler, { capture: true });
```

### 10.3 passive 对 touchstart/touchmove 默认开启

避免阻塞滚动。

## 🔥 总结

JS 事件模型 = 事件流（捕获 → 目标 → 冒泡） + 阻止传播 + 默认行为 + 事件委托 + 微任务关系 + 框架合成事件。

1. 浏览器事件流 3 阶段
2. addEventListener(options)
3. stopPropagation vs stopImmediatePropagation
4. event.target vs event.currentTarget
5. 事件委托（减少监听、性能）
6. 事件同步执行，微任务插队
7. React 的事件是合成事件（事件委托实现）
