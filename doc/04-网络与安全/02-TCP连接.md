# TCP 连接

## 📌 一、TCP 基本介绍

- TCP（Transmission Control Protocol）是面向连接、可靠传输的传输层协议
- 主要特性：
  - 面向连接（需三次握手建立连接）
  - 可靠传输（确认应答、超时重传）
  - 有序传输（按顺序交付）
  - 全双工通信（双方都可以同时发送数据）

## 🤝 二、三次握手（建立连接）

### 🌐 场景：

客户端向服务端发起连接请求

### 🔁 过程如下：

1. 客户端 → 服务端（SYN）
   - 客户端发送一个 SYN 报文，表示要建立连接
   - 包含初始序列号 seq = x
2. 服务端 → 客户端（SYN + ACK）
   - 服务端收到请求后，发送一个确认包（ACK）+ 同时发送自己的 SYN 报文
   - seq = y, ack = x + 1
3. 客户端 → 服务端（ACK）
   - 客户端收到 SYN+ACK 后，再发送一个 ACK 报文，表示连接建立
   - ack = y + 1

👉 至此，连接建立成功，进入数据传输阶段。

### 🔍 面试考点：

为什么是三次？两次不行吗？

> 防止失效连接请求再次到达服务器，引起错误。（旧连接残留 SYN，造成资源浪费）

## ❌ 三、四次挥手（断开连接）

### 🔁 过程如下：

1. 客户端 → 服务端（FIN）
   - 客户端请求断开，发送 FIN 报文
2. 服务端 → 客户端（ACK）
   - 服务端确认收到，发送 ACK 报文（此时连接是半关闭）
3. 服务端准备断开（数据传输结束）
   - 等数据传输完毕，再发送 FIN 报文
4. 客户端 → 服务端（ACK） - 客户端确认后断开
   👉 客户端进入 TIME_WAIT 状态（等待 2 倍最大报文寿命），确保服务端收到 ACK，避免报文丢失。

### 🔍 面试考点：

1. 为什么是四次？不能三次？

   > 因为 TCP 是全双工的，断开连接必须双向关闭。

2. TIME_WAIT 状态为什么需要？

   > 确保最后一个 ACK 能被服务端确认，如果 ACK 丢了，服务端会重发 FIN。

## 🧠 四、连接状态（TCP 状态机）

```text
CLOSED → SYN_SENT → ESTABLISHED → FIN_WAIT_1 → FIN_WAIT_2 → TIME_WAIT → CLOSED
                                     ↑           ↓
                                CLOSE_WAIT ← LAST_ACK ← ESTABLISHED
```

常见状态含义：

| 状态         | 含义                      |
| ------------ | ------------------------- |
| LISTEN       | 服务端监听连接请求        |
| SYN_SENT     | 客户端已发送 SYN 等待回应 |
| SYN_RECEIVED | 服务端收到 SYN            |
| ESTABLISHED  | 连接已建立                |
| FIN_WAIT_1/2 | 等待对方关闭              |
| TIME_WAIT    | 等待 2MSL，防止旧包干扰   |
| CLOSE_WAIT   | 等待本地关闭连接          |
| LAST_ACK     | 等待最后一个 ACK          |

## 🛠️ 五、TCP 可靠性机制

| 机制            | 描述                         |
| --------------- | ---------------------------- |
| 序列号（Seq）   | 保证顺序                     |
| 确认应答（Ack） | 确认成功收到                 |
| 超时重传        | 丢包重发                     |
| 滑动窗口        | 控制流量，避免拥塞           |
| 拥塞控制        | 慢启动、拥塞避免、快速重传等 |

## 🧪 六、常见面试题

- 三次握手过程？为什么需要三次？
- 四次挥手过程？TIME_WAIT 是什么？
- 如何避免 TIME_WAIT 太多？
- TCP 和 UDP 的区别？
- 滑动窗口和拥塞控制原理？
- 粘包/拆包是什么？如何处理？
- 服务端收到 SYN 后直接发送 RST 是什么情况？
