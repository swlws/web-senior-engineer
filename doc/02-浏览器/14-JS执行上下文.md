# JS 执行上下文

## 🌟 什么是 JavaScript 的执行上下文（Execution Context）

执行上下文 = JS 引擎执行一段代码时的运行环境。

理解为：

> “当前环境下，变量在哪、函数在哪、this 指向谁、作用域链是什么、如何管理内存” 等全部由执行上下文控制。

每当 JS 引擎要执行代码（全局代码、函数代码、eval），就会创建一个新的执行上下文并压入 `执行上下文栈（EC Stack）`。

## 🧱 三种类型的执行上下文

| 类型             | 说明                          |
| -------------- | --------------------------- |
| **全局执行上下文**    | 代码第一次运行时创建一个，全局唯一，直到页面关闭才销毁 |
| **函数执行上下文**    | 每调用一次函数就会创建一次               |
| **Eval 执行上下文** | 在 eval 内部创建，不推荐使用           |

在真实项目中，99% 的执行上下文来源于函数调用。

## 🔥 一个上下文里包含什么？

每个执行上下文都会创建三个最关键的组件：

```txt
Execution Context {
  VO / AO: 变量环境 (Variable Environment)
  LE: 词法环境 (Lexical Environment)
  this: this binding
}
```

### 1. 变量环境（Variable Environment）

用于存储：

- var 声明的变量
- 函数声明（Function Declaration）

特点：

- 变量提升发生在变量环境中
- var 在创建阶段就会被加入环境，值为 undefined

例：

```js
console.log(a); // undefined
var a = 1;
```

### 2. 词法环境（Lexical Environment）

用于存储：

- let 和 const
- 函数内部声明的函数表达式
- 块级作用域（if、for、try/catch）

特点：

- let/const 不会提升到可用，只提升“声明”
- 因此会产生 暂时性死区（TDZ）

例：

```js
console.log(a); // ReferenceError
let a = 1;
```

词法环境也包含：

- 外部环境引用（outer environment reference）：用于构成作用域链

### 3. this 绑定（This Binding）

进入执行上下文时确定：

- 全局上下文：this = window
- 函数上下文：由调用方式决定

例：

```js
obj.fn()   // this -> obj
fn()       // this -> window
new Fn()   // this -> 新实例
```

## 🧩 执行上下文创建的两个阶段

### ① 创建阶段 (Creation Phase) —— 做准备

包括：

- ✔ 1. 建立变量环境（处理 var）
- ✔ 2. 建立词法环境（处理 let/const/block）
- ✔ 3. 创建作用域链
- ✔ 4. 确定 this 绑定

### ② 执行阶段 (Execution Phase) —— 运行实际代码

此阶段：

- 给变量赋具体值
- 执行函数体
- 执行表达式
- 触发微任务/宏任务

## 🔗 执行上下文栈（Execution Context Stack）

执行代码如下：

```js
function a() {
  function b() {}
  b();
}
a();
```

执行上下文栈变化：

```txt
ECStack = []

--- 执行全局代码 ---
push(GlobalEC)

--- 调用 a() ---
push(EC of a)

--- 调用 b() ---
push(EC of b)

--- b() 执行完 ---
pop()

--- a() 执行完 ---
pop()

--- 程序结束 ---
pop(GlobalEC)
```

## ♻ 执行上下文与作用域链

作用域链由 当前词法环境 的外层引用逐级向外，最终指向全局。

闭包的本质：

> 函数执行上下文结束后，但其词法环境没有被释放，因为仍然被其他函数引用。
