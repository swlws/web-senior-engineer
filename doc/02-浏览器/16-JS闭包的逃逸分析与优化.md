# JS 闭包的逃逸分析与优化

## 🚀 1. 什么是“逃逸”？

逃逸（Escape）= 一个变量不再只在当前函数内部使用，而是被外部引用，从而不可在栈上分配，只能进入堆。

闭包就是最典型的逃逸场景：

```js
function outer() {
  let a = 1;
  return function inner() {
    console.log(a);  // a 被 inner 闭包引用 → 逃逸
  };
}
```

变量 a 被 inner 引用，因此：

- 不能放在栈上（栈帧结束会销毁）
- 必须分配到 堆，存入 Context Object（上下文对象）
- outer 执行结束后，其作用域不被回收

## 🚀 2. V8 如何分析闭包是否“逃逸”？—— Escape Analysis

V8 在编译阶段（Ignition/bytecode 生成阶段）会进行：

- ✔ 变量是否逃逸？

规则（重点）：

### ① 是否被嵌套函数引用？

```js
function outer() {
  let x = 1; 
  function inner() {
    console.log(x); // x 逃逸
  }
}
```

### ② 是否可能在异步任务中使用？

```js
let x = 1;
setTimeout(() => console.log(x), 1000); // x 逃逸
```

### ③ 是否存到某个对象里并返回？

```js
function outer() {
  let x = 1;
  return { x }; // x 逃逸
}
```

### ④ 是否赋值给全局变量？

```js
function outer() {
  let x = 1;
  window.xx = () => x; // x 逃逸
}
```

## 🚀 3. 不逃逸的变量 = 可以放栈上 + 可做优化

例如：

```js
function outer() {
  let a = 1;
  let b = 2;

  return function inner() {
    console.log(a);
  };
}
```

V8 的逃逸分析结果：

| 变量  | 是否被 inner 引用 | 是否逃逸        |
| --- | ------------ | ----------- |
| `a` | ✔            | ✔ 逃逸到堆      |
| `b` | ✖            | ✖ 不逃逸，仍存在栈上 |

V8 会将 b 优化掉（栈上短生命周期变量）。

## 🚀 4. V8 如何表示闭包中的变量？—— Context Object

当一个变量逃逸后：

V8 会创建一个 Context（上下文对象）：

（可以理解为一个存储闭包变量的对象）

```bash
Context {
  slot_0: a
  slot_1: other escaped variables
}
```

inner 函数内部的字节码会引用该 Context：

```bash
LdaContextSlot context[0], slot_0  // load context variable a
```

所以闭包其实就是：

> 内部函数持有对外层 Context Object 的引用

这也解释了为什么闭包变量会继续存在。

## 🚀 5. 闭包过多为什么会影响性能？

原因来自：

| 性能问题                          | 原因                  |
| ----------------------------- | ------------------- |
| **更多变量逃逸到堆**                  | 导致频繁 GC             |
| **更多 context 对象**             | 每层嵌套都可能产生一个 Context |
| **优化器（TurboFan）无法做标量替换**      | 逃逸变量不能内联或 SRA       |
| **字节码执行需要额外的 ContextSlot 读写** | 比直接读栈或寄存器要慢         |

## 🚀 6. V8 的逃逸优化：标量替换（Scalar Replacement）

前提：变量完全不逃逸。

V8 TurboFan 会把对象在栈上“拆开”，甚至完全消除。例：

```js
function test() {
  let obj = { x: 1, y: 2 };
  return obj.x + obj.y;
}
```

因为 obj 不逃逸，TurboFan 优化：

- ✔ obj 不真正分配
- ✔ x 和 y 会成为两个 寄存器值
- ✔ 最终直接做常量折叠 → 在运行前就计算出结果

## 🚀 7. 如何写出对 V8 更友好的闭包？（工程实践）

### ✔ 1. 避免不必要的闭包

🚫 Bad

```js
btn.onclick = () => console.log(this.id);
```

✅ Better

```js
btn.onclick = handleClick;
```

✔ 为什么更优？

1. 避免每次创建新的闭包函数对象
   - ()=>console.log() 每次赋值都是新函数 → 不可内联优化
   - handleClick 是一个 稳定函数（stable function） → 可 inline → 生成更优化的机器码
2. 闭包捕获 this，导致 this 逃逸
   - 箭头函数会捕获外层 this → 产生闭包 → 生成 ContextObject
   - handleClick 独立函数 → 不捕获外部变量 → 不生成 ContextObject
3. 减少字节码和堆分配
   - Bad 需要生成一个新的 Function 对象 + Context
   - Better 使用已有函数 → 无额外分配

对 V8 来说：

- ✔ 更少的分配 → GC 压力更小
- ✔ 更少闭包 → 更容易 inline
- ✔ 更快执行

### ✔ 2. 避免把大量数据放入闭包

Bad：

```js
function foo(hugeData) {
  return () => process(hugeData);
}
```

hugeData 会逃逸，引发 GC 成本。

Better：传入参数

```js
function foo() {
  return data => process(data);
}
```

✔ 为什么更优？

1. 避免让 hugeData 逃逸到堆上
   - Bad 中闭包捕获 hugeData → hugeData 逃逸 → 必须放 Context 上 → 保持存活
   - hugeData 很大，就会一直占内存 → 延迟 GC
2. Better 中 hugeData 变成参数传入 → 不逃逸
   - data 由调用方控制，closure 不需要持有
   - V8 不需要为 hugeData 创建堆上的 slot
3. 减少闭包持有大对象导致的 GC 代价

实际成本差异非常明显：

- ⭐ Bad：闭包导致巨大对象延长生命周期
- ⭐ Better：large data 完全不在闭包内

这是最常见的闭包泄漏场景。

### ✔ 3. 不要在 for 循环中创建闭包引用巨大外部变量

Bad：

```js
for (var i = 0; i < 10000; i++) {
  list.push(() => hugeArray[i]);
}
```

Better：

```js
for (let i = 0; i < 10000; i++) {
  const item = hugeArray[i];
  list.push(() => item);
}
```

✔ 为什么更优？

理由 1：var 不创造块级作用域，所有闭包共享同一个 i（逃逸必然发生）

- 导致所有闭包捕获同一变量 i → 逃逸 → Context 分配
- 10000 次循环会创建 10000 个闭包引用同一个 i → 增大 Context 压力

理由 2：hugeArray[i] 会导致闭包引用整个 hugeArray

- 因为闭包中“访问 hugeArray[i]”，意味着 hugeArray 逃逸
- → hugeArray 的生命周期被闭包拉长

Better 的机制：

- let i → 每轮循环创建独立词法作用域 → i 不共享
- item = hugeArray[i] → 闭包只捕获 item（一个简单类型）
- hugeArray 不逃逸（上下文中根本不引用它）

即 闭包从引用整个 hugeArray → 只引用一个简单数值 item
内存占用降低至少 10000 倍（真实情况常常更多）

### ✔ 4. 避免返回包含闭包的对象（深度逃逸）

Bad：

```js
return { a, b, c: () => a + b };
```

Better：

```js
return value => value + 1;
```

✔ 为什么更优？

1. Bad 让 a, b 逃逸（因为闭包引用它们）
2. 返回对象，会让整个创建链逃逸（object 也逃逸）
3. 闭包捕获外层环境 → 更重的 Context
4. Better 是一个轻量、无捕获（no-capture）的闭包
   - 不引用外层变量
   - ContextObject 不创建
   - TurboFan 可以 inline + scalar replace

Better 的闭包几乎是 零成本闭包（Zero-Cost Closure）。

### 📌 这些写法为什么 “对 V8 更友好”？

从 V8 底层（Ignition + TurboFan）机制来看，Better 的写法具有：

| 优化点                              | Good 写法效果                 |
| -------------------------------- | ------------------------- |
| **避免变量逃逸**                       | 减少 ContextObject 创建       |
| **减少闭包捕获变量数量**                   | V8 更容易 inline             |
| **减少堆分配（Heap Allocation）**       | 降低 GC 成本                  |
| **让函数成为 "stable function" 稳定函数** | TurboFan 更容易生成优化代码        |
| **减少作用域链深度**                     | 字节码执行更快（LdaContextSlot）更少 |
| **允许更多标量替换（SRA）优化**              | 对象/变量内联成寄存器值              |

## 🚀 8. “闭包导致内存泄漏”是真的吗？

❌ 闭包本身不会泄漏，闭包变量是受 GC 管理的。

真实导致泄漏的情况是：

- ✔ 闭包被 全局引用（比如存在于 window 上）
- ✔ 闭包保留了引用巨大对象
- ✔ DOM 与闭包形成循环引用（现代浏览器会打破，但数据仍可能逃逸）

## 🚀 9. 最终总结

V8 会对每个变量做逃逸分析，判断它是否会被函数外部引用。如果变量不逃逸，可以在栈帧里分配并做激进优化；如果逃逸，就必须存入堆中的 Context Object，被闭包捕获。闭包过多会导致更多变量逃逸、更多 Context 对象、GC 压力上升、字节码加载更慢。而 V8 的 TurboFan 会对未逃逸变量做标量替换，把对象拆成寄存器值甚至完全消除，从而显著提升性能。
