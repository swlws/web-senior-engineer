# 作用域

## 🔥 一句话总结作用域（Scope）

作用域 = 标识符（变量）在代码中的可访问范围。

它回答的问题是：

> “在这一行代码，某个变量能不能被访问到？”

## 🧱 JavaScript 的三种作用域类型

| 作用域类型     | 是否产生新的作用域？ | 示例                       |
| --------- | ---------- | ------------------------ |
| **全局作用域** | 全局唯一       | 顶层代码                     |
| **函数作用域** | ✔ 产生       | function 内               |
| **块级作用域** | ✔ 产生（ES6）  | `{}`, if, for, try/catch |

**📝 为什么以前只有函数作用域？**

因为 ES5 时代只有 var，它不支持块级作用域。

## 🌳 作用域链（Scope Chain）

当 JS 引擎查找变量时，会按照以下路径逐级向上：

```txt
当前作用域 → 外层作用域 → ... → 全局作用域
```

本质是：

> 词法环境（Lexical Environment）中的外部环境引用（Outer Environment Reference）链。

示例：

```js
let a = 1;
function outer() {
  let b = 2;
  function inner() {
    console.log(a, b); 
  }
}

```

作用域链：

```txt
inner → outer → global
```

## 🧬 词法作用域 vs 动态作用域

JS `是词法作用域（Lexical Scope）语言`，不是动态作用域。

### ✔ 词法作用域

作用域在 `代码编写阶段` 就确定了（既非调用决定，也非运行时改变）。

```js
var x = 1;
function foo() {
  console.log(x); 
}

function bar() {
  var x = 2;
  foo();
}

bar(); // 1（不是 2）
```

因为 foo 的作用域在声明时就确定，不被调用位置影响。

### ✖ 动态作用域（例如 Bash、某些 Lisp）

作用域由 调用位置决定，JS 没有。

## 🧩 块级作用域（ES6 新增）

所有的 `{}` 都有块级作用域（包括 `if、for、while、try/catch` 等）。

例：

```js
{
  let x = 1
}
console.log(x) // ReferenceError
```

重点行为：

- let/const 只在块级作用域有效
- 有 `暂时性死区（TDZ）`

## 🔒 作用域和闭包的关系

闭包的本质：

> 一个函数“记住了”它出生时的作用域（词法环境），即使外层函数已经执行完毕。

例：

```js
function outer() {
  let a = 1
  return function inner() {
    console.log(a)
  }
}
```

即使 `outer()` 已经结束，它的词法环境仍被 inner 引用，因此不会被 GC 回收。

## 🔥 面试常问：作用域与执行上下文区别

| 执行上下文            | 作用域             |
| ---------------- | --------------- |
| 是“执行环境”（Runtime） | 是“可访问范围”（Space） |
| 每次执行函数都会创建       | 在代码书写时决定        |
| 包含变量环境、词法环境、this | 只是变量查找的规则和边界    |
| 是运行时概念           | 是编译阶段决定的概念      |

👉 作用域更偏“静态”，执行上下文更偏“动态”。

## 💣 常见陷阱：for + var 的作用域问题

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 0)
}
```

输出 3 3 3，因为 var 没有块级作用域，所有闭包共享同一个 i。

用 `let` 解决：

```js
for (let i = 0; i < 3; i++) { ... }
```

## 🧠 再总结（话术）

JavaScript 是词法作用域语言，变量的可访问范围在代码编写阶段就确定了。作用域分为全局、函数和块级三种，每个函数都会创建新的作用域，块级作用域由 let/const 引入。变量查找时会沿着作用域链逐级向外查找，链的结构由词法环境中的外层引用决定。作用域是静态概念，而执行上下文则是在运行时由引擎创建的环境，两者相互关联但不是一个东西。闭包的本质是内部函数引用了外层作用域而导致该作用域没有被释放。
