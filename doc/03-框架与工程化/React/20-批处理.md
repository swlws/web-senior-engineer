# 批处理

React 的「批处理（Batching）」是它性能优化的核心机制之一。我们来深入讲清楚：

## 🚀 一、什么是批处理（Batching）

批处理指的是：

> React 在一次事件循环中收集多次状态更新（setState / useState），再一次性执行渲染，避免多次重复渲染。

比如：

```jsx
setCount(count + 1);
setName("Tom");
```

在 批处理模式 下，这两次更新不会触发两次组件重新渲染，而是被合并成一次渲染。

## ⚙️ 二、为什么需要批处理

如果没有批处理：

```jsx
setCount(count + 1); // -> render 1 次
setName("Tom"); // -> 再 render 1 次
```

## 🧩 三、React 不同时代的批处理机制

### ✅ React 17 及之前

只有在 React 控制的事件中（如 onClick、生命周期等），才会进行批处理。
在异步回调（比如 setTimeout、Promise.then）中，不会批处理。

```jsx
// React 17
function App() {
  const [count, setCount] = useState(0);
  console.log("render", count);

  const handleClick = () => {
    setTimeout(() => {
      setCount((c) => c + 1);
      setCount((c) => c + 1);
      // React 17: 会渲染两次！
    }, 0);
  };
  return <button onClick={handleClick}>click</button>;
}
```

### ⚡ React 18 之后（自动批处理 Automatic Batching）

React 18 引入了 自动批处理机制，覆盖了更多情况。
即使在 setTimeout、Promise、fetch、await 中，也会自动批处理。

```jsx
// React 18
setTimeout(() => {
  setCount((c) => c + 1);
  setCount((c) => c + 1);
  // ✅ 只渲染 1 次
}, 0);
```

这得益于 React 18 的 Concurrent Mode / Fiber 调度系统。

## 🧠 四、原理简化理解

在 Fiber 架构下，每次状态更新时 React 会：

1. 先记录一次更新（放入队列）；
2. 不立即执行渲染；
3. 等本轮事件循环结束或调度器空闲时，再统一执行「reconcile + commit」。

这就形成了：

- 可中断（interruptible） → 渲染任务可以暂停；
- 可合并（batchable） → 多个更新可以合并；
- 可延迟（deferable） → 可以延迟到合适时机执行。

## 🧩 五、手动控制批处理

React 提供了 `flushSync`，可以`强制立即更新`（跳过批处理）：

```jsx
import { flushSync } from "react-dom";

flushSync(() => {
  setCount(count + 1);
});
// 此时立即重新渲染
```

常见于需要立即读取最新 DOM 状态的场景。

## 🧮 六、与 Vue 的区别对比

| 特性         | React                                | Vue（2/3）                               |
| ------------ | ------------------------------------ | ---------------------------------------- |
| 更新合并策略 | 批处理（Batching）                   | 微任务队列（nextTick）                   |
| 更新触发时机 | 调度器统一调度                       | nextTick 统一异步更新                    |
| 异步回调中   | React17 不批处理，React18 自动批处理 | Vue2/3 都异步批量更新                    |
| 强制立即更新 | `flushSync()`                        | `Vue.nextTick()`（反过来控制异步后获取） |
