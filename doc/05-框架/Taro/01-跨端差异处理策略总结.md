# 跨端差异处理策略总结

在 Taro / 小程序 / 多端项目中通用的“跨端差异处理策略总结”, 涵盖从编码、工程、架构到调试的完整策略。

## 🧭 跨端差异处理总体原则

跨端差异不可避免，但可以通过工程体系和架构设计让它：

- 可控
- 可定位
- 可维护
- 可扩展

核心理念是：

> 将差异收敛在固定位置，而不是散落在业务代码里。

## 🧩 一、跨端差异的主要来源

Taro / 多端开发中差异基本来自：

1. API 差异
   - Taro.xxx 并非所有端均支持
   - 部分 platform 特有功能
2. 组件差异
   - input、picker、scroll-view、rich-text 在不同端能力不同
3. 事件差异
   - Web 的 DOM event
   - 小程序的 bindtap / onInput / capture 系统差异
4. 样式差异
   - rpx 转 px
   - flex、position、overflow 支持的不一致
5. 运行时差异
   - RN（JS 线程 + Native 线程）
   - 小程序（setData / 渲染层通信）
   - H5（DOM）
6. 打包构建差异
   - polyfill 支持不一致
   - 插件机制不一致

了解差异来源能帮助分类处理。

## 🧱 二、跨端差异处理的黄金策略（强烈推荐使用）

以下是成熟团队都会采用的结构化策略。

### ① 分层架构：将差异框在底层

推荐架构：

```txt
src/
  shared/           <-- 可复用逻辑（Hooks / composables）
  components/       <-- 跨端统一组件
  platform/         <-- 平台差异文件（Platform Adapters）
      web.ts
      weapp.ts
      alipay.ts
      reactnative.ts
  utils/
      platform.ts   <-- 平台检测 + 能力 polyfill
```

目标：业务代码完全“感觉不到”差异，只由 adapter 层处理。

### ② 使用 platform adapter（平台适配器模式）

典型写法：

```ts
// platform/index.ts
import weappAdapter from "./weapp";
import webAdapter from "./web";
import alipayAdapter from "./alipay";

const adapterMap = {
  weapp: weappAdapter,
  h5: webAdapter,
  alipay: alipayAdapter,
};

export const platform = adapterMap[Taro.getEnv()];
```

业务代码：

```ts
platform.openFile(filePath);
platform.chooseImage();
platform.pay();
```

> 差异都集中到适配器中，不侵入业务逻辑。

### ③ Hook 层隔离（React / Vue3 最有效）

跨端逻辑写在 Hook 内，而不是组件内：

```ts
// shared/hooks/useLogin.ts
export function useLogin() {
  const doLogin = () => platform.login();
  return { doLogin };
}
```

组件：

```ts
const { doLogin } = useLogin();
```

> 差异屏蔽在 Hook 内部，使 UI 组件完全跨端复用。

### ④ 使用条件编译（仅在必要时）

Taro 提供：

```ts
if (process.env.TARO_ENV === "weapp") {
}
if (process.env.TARO_ENV === "h5") {
}
```

或者：

```ts
// #ifdef weapp
wx.login();
// #endif

// #ifdef h5
window.location.href = "/login";
// #endif
```

- 使用原则：只用来解决非常明确且不可抽象的差异。
- 禁止将条件编译写满业务组件 → 失控。

### ⑤ 使用统一组件库（减少组件差异）

如：

- NutUI Taro
- Taro UI
- Vant + 跨端适配层

这些库有：

- scroll-view 封装
- picker 优化
- form 组件多端兼容

可以避免大量底层兼容代码。

### ⑥ 做一层 polyfill（能力补齐层）

例如微信小程序有但 H5 没有：

```ts
// utils/polyfill.ts
export function vibrateShort() {
  // https://developers.weixin.qq.com/miniprogram/dev/api/device/vibrate/wx.vibrateShort.html
  // 使手机发生较短时间的振动（15 ms）。仅在 iPhone 7 / 7 Plus 以上及 Android 机型生效
  if (Taro.getEnv() === "weapp") {
    return Taro.vibrateShort();
  }
  if (Taro.getEnv() === "h5") {
    return navigator?.vibrate?.(20);
  }
}
```

## ⚙️ 三、样式差异处理策略

### ① 尽量使用 rpx/px 统一方案

- H5 端通过 postcss-px-transform 自动替换。
- RN 端使用 StyleSheet 换算。

### ② 避免使用强依赖 DOM 的样式

如：

- overflow: scroll（小程序兼容度差）
- position: sticky（快手/百度小程序支持不一致）
- clip-path（部分端不支持）

### ③ 使用 UI 布局组件减少差异

如：

- Flex 布局封装组件 Row / Col
- SafeArea 组件（底部安全区）

## 📦 四、事件差异处理策略

事件差异是最容易踩坑的问题（input、touch、scroll）。

推荐做法：

### ① 对 input 做统一 adapter

```ts
onChange → e.detail.value（小程序）
onChange → e.target.value（H5）
onChange → e.nativeEvent.text（RN）
```

可以统一一个 util：

```ts
export function getValue(e) {
  return e?.detail?.value ?? e?.target?.value ?? e?.nativeEvent?.text;
}
```

## 🧬 五、复杂组件的跨端兼容策略

### ① 尽量不直接写复杂逻辑组件

例如：

- 大型 table
- 富文本编辑器
- 虚拟列表
- 地图
- Canvas 图表

原则：用第三方库 + adapter 层替你处理兼容性。

## 🔧 六、跨端调试策略

### ① 单端先跑通，再做多端

先 H5 或微信端跑通逻辑，再扩展其他平台。

### ② 用 Snapshot 测试关键逻辑

尤其 Hook 层 / util 层。

### ③ 建立测试账号矩阵

微信 / 支付宝 / 抖音小程序都需要基于真实环境测试。

## 📘 七、真实团队生产级“跨端差异治理”经验总结

1. 禁止随意使用 process.env.TARO_ENV（必须集中管理）
2. 所有跨端差异必须通过 platform/xxx.ts 处理
3. 新功能必须同时编写 H5 + Weapp 逻辑（至少 stub）
4. hook = 业务逻辑 / component = UI
5. 复杂场景优先选原生组件（如地图、视频、扫码）
6. 编写自动化测试覆盖关键 Hook
7. 文档化差异点（团队 wiki）

## 🧭 最终总结（可做为团队规范）

- 跨端差异不是靠代码堆出来的，而是靠架构和规范治理。
- 最佳方案是“差异集中化 + 业务无差异”。
