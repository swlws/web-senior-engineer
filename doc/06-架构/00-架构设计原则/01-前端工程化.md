# 前端工程化

前端工程化，本质是用工程的思想和工具体系去管理前端项目的整个生命周期，从开发、调试、构建、质量、部署到协作，帮助前端团队把“写页面”这件事变得可规模化、可维护、可持续演进。

## 🚀 一句话总结

前端工程化 = 标准化流程 + 自动化工具链 + 可度量质量体系 + 可演进架构体系

## 1️⃣ 前端工程化的核心目标

除了“提高效率”，更底层的动机是让前端项目具备：

| 目标             | 解释                                           |
| ---------------- | ---------------------------------------------- |
| **可维护性**     | 代码结构清晰、模块化、能分工协作、不怕人走     |
| **稳定性**       | 不因小修改破坏大功能，有完善检测机制           |
| **可持续演进性** | 架构可扩展、构建可优化、依赖可升级             |
| **一致性**       | 每个人写出的代码风格、目录结构、提交流程都一致 |
| **可度量**       | 性能、包体积、覆盖率、变更成本都可量化         |

## 2️⃣ 工程化不是某个工具，而是一套体系

可以拆成 4 大层 + 18 个关键点

### 🔧 A. 研发基础层：规范、工具、环境

#### 开发环境统一

- Node 版本、包管理器、浏览器兼容目标、ES 标准、运行命令统一
- 通过 nvm, .nvmrc, .browserslistrc, pnpm workspace 统一。

#### 2. 代码规范化

- ESLint（语法、风格）
- Prettier（格式化）
- Stylelint / Commitlint
- Husky + lint-staged（提交前自动检查）

👉 目标：每个人写的代码都“像同一个人写的”。

#### 3. 目录结构规范

带有可扩展性的分层结构：

```txt
/src/pages
/src/components
/services
/utils
/hooks
/core
…
```

#### 4. 模块化体系

使用 ES Modules, CommonJS, UMD, Monorepo（pnpm workspaces + TurboRepo）。

### 🛠 B. 构建层：自动化构建与资源优化

#### 5. 构建工具链

Webpack / Vite / Rollup / esbuild

解决：

- 模块打包
- 压缩、摇树、分包
- 代码切割（Code splitting）
- Hash 产物
- 静态资源优化（图片、字体、CSS）

#### 6. 本地开发支持

- HMR（热更新）
- Source map
- Mock 服务
- Proxy 代理
- 自动注入环境变量

#### 7. 产物优化

- Tree-shaking
- Scope-hoisting
- Minify
- Preload/Prefetch
- CDN 资源拆分

### 🔍 C. 质量保障层：测试、检测、监控

#### 8. 自动化测试体系

- 单元测试：Jest / Vitest
- 端到端：Cypress / Playwright
- UI Snapshot
- Mock & Stub

#### 9. 类型系统

- TypeScript（最重要的工程化进步）
- API 类型生成（OpenAPI -> TS）

#### 10. 静态分析 & 风险检测

- ESLint
- Unused files detector
- Bundle analyzer
- 是否使用废弃 API 自动检查

#### 11. 性能分析

构建产物体积分析、首页秒开率、Web Vitals、LCP/FID/CLS。

### 🚚 D. 交付层：CI/CD，版本管理，多环境

#### 12. Git 流程规范

- Git flow / trunk-based
- PR 模板
- 变更集（changesets）自动生成版本号

#### 13. 持续集成（CI）

每次 PR 自动：

- Lint
- Test
- Build
- 类型检查
- Bundle 大小对比

#### 14. 自动部署

CD 流程：

- Dev
- QA
- Pre
- Prod
- 自动产物上传 CDN
- 内容发布安全控制（灰度发布）

#### 15. 环境配置管理

- `.env.*`
- 多环境注入构建
- secrets 管理

#### 16. 监控 & 埋点系统

- 性能监控（FMP/LCP）
- JS 错误收集
- 行为分析（PV/UV/页面停留）
- 资源加载监控

#### 17. 可观测性（Observability）

Sentry、Apm、日志追踪、前后端链路追踪。

##### 18. 低代码/自动化成长能力

工程化最终可进化到：

- 微前端
- 组件库
- 自动化创建脚手架
- 自动化产物分析告警

## 3️⃣ 工程化 ≠ 工具，而是思维方式

面对任何需求，你应该自动问自己：

- ✔ 1. 是否重复劳动？能否自动化？
  （脚手架、CLI、代码生成）
- ✔ 2. 是否能保证稳定性？
  （lint、test、CI）
- ✔ 3. 是否能扩展到多人协作？
  （目录规范、模块化）
- ✔ 4. 是否可持续演进？
  （抽象合理、组件复用、文档体系）
- ✔ 5. 是否可量化？
  （体积、性能、覆盖率）

这就是“工程化思维”。

## 4️⃣ 前端工程化的一张总图

```txt
[规范化]
  ├─ 代码规范/目录规范/提交规范
[自动化]
  ├─ 构建工具/脚手架/CI/CD
[模块化]
  ├─ ESM/组件化/Monorepo
[质量保障]
  ├─ Lint/TypeScript/测试体系
[交付体系]
  ├─ 版本管理/自动部署/CDN
[可观测性]
  ├─ 性能监控/错误监控/埋点

```
