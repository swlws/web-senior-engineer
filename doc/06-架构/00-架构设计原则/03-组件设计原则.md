# 组件设计原则

## 🧩 1. 组件分层架构模型（从抽象到落地）

前端组件最容易混乱的原因是：UI + 逻辑 + 状态杂糅。

👉 正确方式是 分层 + 抽象。

### （1）组件 4 层模型

```txt
┌───────────────────────────────┐
│ 4. Application Layer   —— 业务容器组件（页面级）   │
├───────────────────────────────┤
│ 3. Feature Layer       —— 复合组件（业务组合逻辑） │
├───────────────────────────────┤
│ 2. Component Layer     —— 通用组件（Button/Input）│
├───────────────────────────────┤
│ 1. Foundation Layer    —— 基础能力（hooks/utils） │
└───────────────────────────────┘
```

每一层的职责：

- 1. Foundation Layer（基础层）
  - hooks（useScroll、useFetch、useDebounce）
  - utils（dom、format、event）
  - 不依赖 UI，纯逻辑复用。
- 2. Component Layer（通用组件层）
  - 无业务特征
  - 可配置（props 驱动）
  - 关注 UI 表现（Button、Modal、Table、Select）
  - React/Vue 世界的“设计体系组件库”
- 3. Feature Layer（业务复合组件）
  - 多个通用组件组合
  - 包含一定业务逻辑（如“搜索表格”、“TagPicker”、“UploadWithPreview”）
- 4. Application Layer（页面组件）
  - 业务流逻辑
  - 调用 feature 组件或通用组件

📌 关键点：越往上越业务化，越往下越通用化。组件问题 90% 都来自“层级边界不清”。

## 🧩 2. 组件架构设计原则（核心思想）

推荐采用 5 大设计原则，确保组件长期可维护。

### 1）单一职责原则（SRP）

组件只做一件事，复杂组件拆为多个子组件。

### 2）数据从外部来（Props-Driven）

- 所有状态应由 props 驱动，除非是组件内纯 UI 状态。
- 不在组件内部偷偷拉接口！

### 3）可控与不可控模式（Controlled / Uncontrolled）

如 Input：

- controlled：value + onChange
- uncontrolled：defaultValue + 内部管理

大组件：如 Table、Form，也要支持此模式。

### 4）可扩展能力（slots / render props / exposed API）

你需要确保组件能被业务“按需加料”。

### 5）对称性原则（Symmetry）

- 有 open，就有 onOpenChange。
- 有 checked，就有 onCheckedChange。
- 有 modelValue（Vue），就有 update:modelValue。

做到 API 成对出现，让组件“直觉易用”。

## 🧩 3. 组件目录结构（真实工程目录示例）

基础组件

```txt
components/
  button/
    index.ts
    Button.vue
    types.ts
    style.scss
    __test__/button.spec.ts
```

复杂组件（含组合逻辑）

```txt
components/
  upload/
    hooks/
      useUpload.ts
      useFileList.ts
    parts/
      UploadList.vue
      UploadItem.vue
    Upload.vue
    index.ts
```

特点：

- ✔ 清晰的领域边界
- ✔ 组件逻辑拆分为 hooks（逻辑）、parts（视图）

## 🧩 4. 组件的状态架构（State Architecture）

组件内部状态需分类：

### 1）UI 状态（内部管理）

tooltip 可见性、loading 开关等，
不暴露给外界。

### 2）外部可控状态（允许父组件接管）

如：

```ts
props: {
  value: { type: String },
  defaultValue: String,
  onChange: Function,
}
```

### 3）派生状态（由 props 计算）

computed/derived state 统一放在一个地方

### 4）跨组件共享状态

不放在组件内部，应该在：

- Pinia / Redux
- context（React）
- provide/inject（Vue）

📌 原则：组件内部不保存业务状态！

## 🧩 5. 组件的扩展能力（开放扩展）

复杂系统必须支持扩展。

### （1）Vue 插槽（Slots）设计规范

- 默认插槽（default）
- 命名插槽（header / footer）
- 作用域插槽（scope）

最佳实践：

- 所有 UI 元素可被业务覆盖
- 但组件核心逻辑（如选择流程）不允许被破坏

### （2）Render Props（React）

```jsx
<Table renderCell={(row, column) => <Cell row={row} />} />
```

### （3）暴露内部方法（expose / forwardRef）

- Vue：defineExpose
- React：forwardRef + useImperativeHandle

适用于复杂组件：Form、Table、Dialog

## 🧩 6. 组件性能架构（Performance Architecture）

从设计阶段就决定性能。

### 1）虚拟化组件

列表 Table、虚拟滚动、虚拟树

### 2）不重复渲染

- key 设计
- memo / shallowRef / computed
- props 不变保证

### 3）合成事件 / 批量更新

- Vue：nextTick 批量 DOM patch
- React：batching（18 默认）

### 4）按需加载

组件级别的 chunk 拆分

## 🧩 7. 组件文档 & 测试体系

高质量组件离不开配套体系：

### 1）Storybook / VitePress 文档体系

每个组件必须包含：

- props 表
- demo 示例
- API 文档
- 交互说明

### 2）单元测试（Vitest / Jest）

重点测试：

- 受控 & 非受控逻辑
- 边界 case（空数据、大数据）
- 渲染结构

### 3）可视化回归测试（Chromatic / Percy）

UI 不可回归！

## 🧩 整体组件架构 Checklist（适合 0→1 项目）

- ✔ 分层：基础层 / 通用组件层 / 业务组件层
- ✔ 组件职责单一
- ✔ Props 驱动 + Controlled 模式
- ✔ 内部逻辑抽成 hooks
- ✔ UI 拆成 parts
- ✔ 扩展能力：slots / render props / expose
- ✔ 无业务逻辑
- ✔ 文档齐全
- ✔ 性能增强：虚拟化、memo、批量更新
