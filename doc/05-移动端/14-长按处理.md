# 长按处理（定时器 + 触摸事件）

「长按（Long Press）」基于定时器 + 触摸事件的完整实现指南，这是移动端交互里非常标准、也很爱考的一题。

按 原理 → 判定条件 → 实现步骤 → 工程级代码 → 常见坑 → 面试总结 来讲。

## 一、长按的本质是什么？

一句话：

> 长按 = 在一定时间内手指不明显移动，也没有抬起。

也就是同时满足：

- 时间 ≥ 阈值（通常 500–800ms）
- 位移 ≤ 阈值（防抖动）
- 没有 touchend / touchcancel

## 二、长按与点击 / 滑动的区分（关键）

| 手势 | 时间 | 位移 |
| ---- | ---- | ---- |
| 点击 | 短   | 小   |
| 长按 | 长   | 小   |
| 滑动 | 任意 | 大   |

👉 位移阈值比时间更重要

## 三、实现长按的核心思路

三步走：

1. touchstart
   - 记录起点
   - 启动定时器
2. touchmove
   - 判断位移
   - 超阈值 → 取消定时器
3. `touchend / touchcancel`
   - 清理定时器

## 四、工程级实现代码（touch 版）

```js
function bindLongPress(el, callback, options = {}) {
  const delay = options.delay ?? 600;
  const moveThreshold = options.moveThreshold ?? 10;

  let timer = null;
  let startX = 0;
  let startY = 0;
  let triggered = false;

  el.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;

    const t = e.touches[0];
    startX = t.clientX;
    startY = t.clientY;
    triggered = false;

    timer = setTimeout(() => {
      triggered = true;
      callback(e);
    }, delay);
  });

  el.addEventListener("touchmove", (e) => {
    if (!timer) return;

    const t = e.touches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;

    if (Math.hypot(dx, dy) > moveThreshold) {
      clearTimeout(timer);
      timer = null;
    }
  });

  el.addEventListener("touchend", cleanup);
  el.addEventListener("touchcancel", cleanup);

  function cleanup() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
}
```

## 五、防止触发 click（非常关键）

问题

- 长按后抬手
- 会继续触发 click

解决方案

```js
el.addEventListener("click", (e) => {
  if (triggered) {
    e.preventDefault();
    e.stopPropagation();
    triggered = false;
  }
});
```

## 六、为什么不在 touchstart 就 preventDefault？

- ❌ 会导致：
  - 页面无法滚动
  - 输入体验变差
- ✅ 正确做法：
  - 只在识别为长按后 才阻止后续行为

## 七、iOS 特有问题（⚠️ 必须知道）

### 1️⃣ 系统上下文菜单（复制 / 放大镜）

iOS 长按会触发：

- 文本选择
- 图片保存菜单

禁用方式

```css
.el {
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
```

### 2️⃣ iOS 震动反馈

```js
navigator.vibrate?.(10);
```

📌 仅部分设备支持

## 八、Pointer Events 版本（更现代）

优点

- 统一 mouse / touch
- 不需要区分平台

```js
el.addEventListener("pointerdown", (e) => {
  startX = e.clientX;
  startY = e.clientY;

  timer = setTimeout(() => {
    callback(e);
  }, 600);
});

el.addEventListener("pointermove", (e) => {
  if (!timer) return;
  if (Math.hypot(e.clientX - startX, e.clientY - startY) > 10) {
    clearTimeout(timer);
    timer = null;
  }
});

el.addEventListener("pointerup", cleanup);
el.addEventListener("pointercancel", cleanup);
```

```css
.el {
  touch-action: none;
}
```

## 九、常见坑总结（面试必会）

| 坑               | 后果       |
| ---------------- | ---------- |
| 忘了 touchcancel | 切后台卡死 |
| 没判断位移       | 滚动误触   |
| 不清 timer       | 内存泄漏   |
| 没阻止 click     | 误操作     |
| 多指未处理       | 逻辑错乱   |

## 十、面试标准回答（一段）

- 长按通常通过 touchstart 启动定时器，在 touchmove 中检测位移并取消定时器，
- 若在指定时间内没有明显移动且未触发 touchend，则判定为长按；
- 实现时需同时处理位移阈值、防止 click 透传、以及 iOS 系统长按菜单等问题。
