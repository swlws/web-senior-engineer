# 小程序局部更新列表

小程序中列表的局部更新 + slice 实现，这是 setData 性能优化的经典方法。核心目标是 避免每次更新整个大数组，而只更新变化部分。

## 一、场景问题

假设我们有一个列表 list，长度 1000，每条 item 有状态字段 checked：

```js
data: {
  list: Array(1000)
    .fill(0)
    .map((_, i) => ({ id: i, checked: false }));
}
```

如果要更新第 500 项的状态：

```js
// 错误写法：更新整个数组
this.setData({
  list: this.data.list.map((item) =>
    item.id === 500 ? { ...item, checked: true } : item
  ),
});
```

问题：

- 每次 setData 都要把 1000 条数据序列化并发送给渲染层
- 桥接成本高，掉帧明显

## 二、局部更新 + slice 原理

思路：

- WXML 支持 `通过路径更新数组或对象的单个字段`
- 使用 slice 或索引获取变化部分
- 用 `list[index].key` 精确更新字段，避免整个数组更新

## 三、具体实现

### 1️⃣ 精确更新单个字段

假设要更新第 500 项 checked：

```js
const index = 500;
this.setData({
  [`list[${index}].checked`]: true,
});
```

效果：

- 仅更新第 500 个 item
- 其他 999 条不受影响
- 数据量小 → 桥接快 → 帧率高

### 2️⃣ 更新多个连续项（slice）

假设我们一次更新列表 500~509 项：

```js
const start = 500;
const end = 510;
const updated = this.data.list.slice(start, end).map((item) => ({
  ...item,
  checked: true,
}));

const setObj = {};
updated.forEach((item, i) => {
  setObj[`list[${start + i}]`] = item;
});

this.setData(setObj);
```

- `slice(start, end)` → 获取要更新的部分
- 遍历生成 setData 对象
- 只发送变化数据到渲染层
- 避免整个大数组序列化

### 3️⃣ 批量高频更新 + 节流

如果用户快速操作多条数据（例如滚动列表中的 checkbox）：

```js
// 防抖/节流
let pending = {};
function updateList(index, value) {
  pending[index] = value;
  clearTimeout(this.timer);
  this.timer = setTimeout(() => {
    const setObj = {};
    Object.keys(pending).forEach((i) => {
      setObj[`list[${i}].checked`] = pending[i];
    });
    this.setData(setObj);
    pending = {};
  }, 50);
}
```

- 合并高频更新 → 减少 setData 次数
- 提升性能

## 四、总结

- 优势
  - 仅发送变化数据 → 减少 JS Bridge 序列化压力
  - 保持大列表高性能渲染
  - 可结合节流防止滚动 / 输入高频触发
- 注意点
  - 不要一次性 slice 整个大列表
  - 每个 setData 对象 key 最好精确到数组索引
  - 对复杂对象，推荐深度拷贝变化部分，避免引用污染

## 五、面试标准回答

小程序`大列表更新`应使用`局部更新 + slice`：

- 通过 slice 获取要更新的数组部分，
- 再用 setData 精确更新 `list[index]` 或`字段`，而不是整个数组，这样可以减少桥接数据量和 JSON 序列化开销，提高渲染性能。
