# 手写实现 Promise

## 实现

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        queueMicrotask(() => {
          this.onFulfilledCallbacks.forEach(fn => fn(this.value));
        });
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        queueMicrotask(() => {
          this.onRejectedCallbacks.forEach(fn => fn(this.reason));
        });
      }
    };

    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
      onRejected = typeof onRejected === 'function' ? onRejected : r => { throw r; };

      const fulfilledTask = () => {
        try {
          const x = onFulfilled(this.value);
          resolvePromise(x, resolve, reject);
        } catch (err) {
          reject(err);
        }
      };

      const rejectedTask = () => {
        try {
          const x = onRejected(this.reason);
          resolvePromise(x, resolve, reject);
        } catch (err) {
          reject(err);
        }
      };

      if (this.state === 'fulfilled') {
        queueMicrotask(fulfilledTask);
      } else if (this.state === 'rejected') {
        queueMicrotask(rejectedTask);
      } else {
        this.onFulfilledCallbacks.push(fulfilledTask);
        this.onRejectedCallbacks.push(rejectedTask);
      }
    });
  }
}

// 用于处理 then 返回值为 promise 的情况
function resolvePromise(x, resolve, reject) {
  if (x instanceof MyPromise) {
    x.then(resolve, reject);
  } else {
    resolve(x);
  }
}
```

调用示例：

```js
new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve(1)
  }, 1000)
}).then(value => {
  console.log(value)
})
```

## 设计模式

Promise 的实现里，其实用到了 多个经典设计模式，而不是单一模式。

### 1. 观察者模式（Observer Pattern）——最核心

Promise 内部维护着：

- onFulfilledCallbacks
- onRejectedCallbacks

这些本质上就是观察者列表。

流程：

1. Promise 初始是 pending
2. .then() 注册观察者（回调函数）
3. resolve/reject 时通知所有观察者，依次执行回调

这完全符合 观察者模式：

> “被观察者（Promise 状态）变化 → 通知观察者（回调队列）执行”

✨ 你写的 then 里的回调队列，就是 Observer

```js
this.onFulfilledCallbacks.push(fn);
this.onRejectedCallbacks.push(fn);
```

### 2. 发布订阅模式（Pub/Sub）——观察者模式的具体表现形式

Promise 的回调执行不是即时的，而是：

- Promise resolve 后通过微任务事件循环发布事件
- then 注册的回调订阅该事件

典型 pub/sub 流程：

1. .then() = subscribe
2. resolve() = publish 成功事件
3. reject() = publish 失败事件

所以 Promise 也属于 发布订阅模式 的实现。

区别：

| 模式       | 特点                |
| -------- | ----------------- |
| **观察者**  | 观察者直接被被观察者通知      |
| **发布订阅** | 有调度中心（事件循环）进行异步调度 |

Promise 属于：异步发布订阅模型（通过微任务队列调度）。

### 3. 状态机模式（State Machine Pattern）——Promise A+ 标准核心

Promise 有三种状态：

- pending
- fulfilled
- rejected

且状态 只能由 pending → fulfilled/rejected（不可逆）。

这完全符合状态机（FSM）模式：

```txt
pending --> fulfilled   （只能一次）
pending --> rejected    （只能一次）
fulfilled --> (不可变)
rejected  --> (不可变)
```

因此 Promise 内部状态变化就是一个典型的 `有限状态机（FSM）`。

## 🔥 最佳答案总结

Promise 的核心设计模式包括：

| 模式         | Promise体现位置                                 |
| ---------- | ------------------------------------------- |
| **观察者模式**  | then/catch 的回调队列监听状态变化                      |
| **发布订阅模式** | 通过事件循环（微任务）调度异步回调                           |
| **状态机模式**  | Promise 状态不可逆（pending → fulfilled/rejected） |
