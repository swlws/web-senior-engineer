# 虚拟列表的实现方案

## 🔎 为什么需要虚拟列表

当列表元素很多（上千甚至上万条）时，如果全部渲染，会造成：

- DOM 节点过多 → 内存占用高
- 渲染慢、滚动卡顿

👉 解决方案就是 只渲染可视区元素，其他区域用占位撑开滚动条，让用户感觉列表完整。

## ⚙️ 虚拟列表的常见实现方案

1. 固定高度（最简单）

- 原理：假设每个 item 高度固定，计算可视区能容纳多少元素，只渲染这部分。
- 实现步骤：
  1. 计算可视区高度 / item 高度 = 同屏数量
  2. 根据 scrollTop 算出起始索引
  3. 渲染 [start, end] 范围的 item，外层容器用 padding-top / translateY 占位

```js
const start = Math.floor(scrollTop / itemHeight);
const end = start + visibleCount;
```

- ✅ 优点：实现简单、性能好
- ❌ 缺点：只适合 高度一致的列表

## 2. 可变高度 + 预估高度

- 原理：item 高度不固定，先用一个预估高度算滚动位置，渲染后再修正。
- 实现步骤：

  1. 维护一个 heights[] 数组，记录已渲染过的真实高度
  2. 没渲染过的用预估值代替
  3. 滚动时动态修正 scrollTop 和占位高度

- ✅ 优点：适合不规则高度
- ❌ 缺点：逻辑复杂，滚动跳动时可能有闪烁

## 3. 动态测量（实时测量高度）

- 原理：渲染时用 ResizeObserver / getBoundingClientRect 测量真实高度，缓存起来
- 实现步骤：
  1. 先渲染部分 item，测量高度
  2. 更新高度缓存，重新计算列表总高度
  3. 滚动时根据缓存精确计算可见区域

✅ 优点：高度准确，用户体验好
❌ 缺点：性能消耗大（频繁测量）

> 备注：当业务中存在上下、左右展开收起行为时，使用此方案。否则，使用【方案 2】更好

## 4. 分片渲染（分批加载）

- 原理：一次只渲染部分数据，用 requestIdleCallback / setTimeout 分批挂载 DOM
- 适合场景：首屏要展示大量 item，但不要求“无限滚动”
- 实现步骤：
  1. 拆成小批次（比如 20 个一批）
  2. 空闲时渲染下一批，避免主线程阻塞

✅ 优点：用户感知更平滑
❌ 缺点：实现复杂，数据量特别大时仍需虚拟滚动配合

## 5. 结合窗口化（Windowing）

- 原理：不光限制可见区域，还在上下加 缓冲区（overscan），提前渲染即将进入视口的数据。
- 实现步骤：
  1. visibleCount = Math.ceil(containerHeight / itemHeight)
  2. 实际渲染 [start - overscan, end + overscan]

✅ 优点：滚动更平滑，不会闪白
❌ 缺点：多渲染一些 DOM，内存稍高

## 6. 专用库实现

- React 生态：
  - react-window（轻量、推荐）
  - react-virtualized（功能更全，支持表格/网格）
- Vue 生态：
  - vue-virtual-scroller
  - Element Plus 的 <ElVirtualList>
- 通用方案：
  - virtual-list 开源组件

## 📊 总结对比

| 方案               | 适用场景         | 优点               | 缺点               |
| ------------------ | ---------------- | ------------------ | ------------------ |
| 固定高度           | 简单列表，等高项 | 实现简单，性能高   | 不适合不规则高度   |
| 预估高度           | 高度差异不大     | 通用性强           | 可能有闪烁         |
| 动态测量           | 高度差异大       | 精确无误           | 性能开销大         |
| 分片渲染           | 首屏大数据渲染   | 避免卡顿           | 实现复杂           |
| 窗口化（overscan） | 无限滚动、长列表 | 平滑滚动体验       | 多渲染少量冗余 DOM |
| 第三方库           | React/Vue 项目   | 开箱即用，成熟稳定 | 需要学习成本       |
