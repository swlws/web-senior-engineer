# 微前端的实现方式

微前端的实现方式主要分为 架构层面 和 技术落地层面 两类思路

## 1. 基于 路由劫持 的方式（常见且易落地）

- 核心思路：主应用（基座）统一接管路由，当路由匹配到某个子应用时，动态加载并渲染它。
- 实现方式：
  - iframe（早期 & 简单，但体验差）
  - 主应用用 <iframe> 嵌入子应用页面
  - 优点：隔离性好（CSS、JS、运行环境），简单易用
  - 缺点：加载慢、SEO 不友好、通信困难、URL 不同步
- JavaScript 动态加载
  - 主应用根据路由下载子应用打包好的 JS/CSS 文件，挂载到指定 DOM 节点
  - 例子：single-spa、qiankun
  - 优点：用户体验好，URL 可同步，支持不同框架共存
  - 缺点：需要解决样式、全局变量冲突，主应用和子应用需约定接入协议

## 2. 基于 构建时集成 的方式（Module Federation / 拼装）

核心思路：通过构建工具（Webpack、Vite 等）在编译阶段将多个子应用的模块组合到主应用中。

- Webpack 5 Module Federation
  - 主应用运行时按需加载子应用暴露的模块
  - 优点：性能好、可复用代码、共享依赖
  - 缺点：构建配置复杂，团队需要统一构建体系
- Monorepo + 组件化
  - 用 Lerna、Nx、Turborepo 等工具将业务拆成多个 package
  - 虽然代码分模块，但最终还是构建成一个产物，不是真正的运行时微前端

## 3. 基于 服务端聚合 的方式（Server Side Composition）

核心思路：由服务器在 HTML 渲染阶段，把不同子应用的 HTML 片段组合起来再返回给浏览器。

- Edge Side Includes (ESI)
  - CDN/反向代理按标签动态拼接不同应用的内容
- BFF（Backend For Frontend）拼装
  - 后端模板引擎（如 Thymeleaf、Freemarker、Next.js SSR）动态拼接
- 优点：首屏性能好，SEO 友好
- 缺点：前后端耦合度高，子应用前后端需同步发布

## 4. 基于 Web Components 的方式

核心思路：子应用打包成原生的 Web Component（Custom Elements），在主应用中像用 HTML 标签一样引用。

- 优点：天然样式隔离（Shadow DOM）、技术栈无关
- 缺点：浏览器兼容性、开发体验差、状态管理和路由需额外处理

## 常见框架/方案

| 实现方式          | 代表方案                            | 特点                         |
| ----------------- | ----------------------------------- | ---------------------------- |
| iframe            | 原生                                | 隔离性最好，但体验差         |
| 路由劫持+动态加载 | single-spa、qiankun、ice-stark      | 最流行，灵活度高             |
| 构建时集成        | Webpack Module Federation、Monorepo | 性能好，依赖共享，但构建耦合 |
| 服务端聚合        | ESI、BFF、Next.js SSR               | 首屏快、SEO 好               |
| Web Components    | 原生、Stencil                       | 技术栈无关，Shadow DOM 隔离  |
