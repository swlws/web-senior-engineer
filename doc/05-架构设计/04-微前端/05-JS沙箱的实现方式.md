# JS 沙箱实现方式

## 1. 核心思路

- 目标：让子应用在访问或修改全局变量时，不污染主应用或其他子应用。
- 方法：用 Proxy 包装 window 对象，拦截 get/set/has 操作。

思路如下：

1. 创建一个空对象 sandbox 作为子应用的“虚拟全局环境”。
2. 用 Proxy 拦截对 window 的访问：
   - get：先从 sandbox 中读取，如果没有再去真实 window
   - set：只修改 sandbox 对象，不影响真实 window
3. 执行子应用的 JS 时，把全局 this 或 globalThis 指向这个 Proxy 对象。

## 2. 简化实现示例

```js
function createSandbox() {
  const sandbox = {}; // 子应用独有的沙箱
  const proxy = new Proxy(window, {
    get(target, prop) {
      if (prop in sandbox) {
        return sandbox[prop]; // 优先返回沙箱里的值
      }
      return target[prop]; // 否则返回真实 window
    },
    set(target, prop, value) {
      sandbox[prop] = value; // 只写入沙箱
      return true;
    },
    has(target, prop) {
      return prop in sandbox || prop in target; // 支持 in 操作符
    },
  });

  return proxy;
}

// 使用沙箱执行子应用代码
const sandbox = createSandbox();

// 模拟子应用 JS
(function (global) {
  global.foo = "子应用变量";
  console.log("子应用读取 foo:", global.foo); // 子应用自己的 foo
  console.log("主应用 window.foo:", window.foo); // undefined，不污染主应用
})(sandbox);
```

运行结果：

```text
子应用读取 foo: 子应用变量
主应用 window.foo: undefined
```

✅ 这样就实现了 子应用可以自由操作全局变量，但不会污染主应用。

## 3. qiankun 的增强点

在真实 qiankun 中，它还做了：

1. 沙箱激活/卸载
   - 卸载子应用时，清空或恢复沙箱，撤销对 window 的临时修改。
2. 快照沙箱兼容低版本浏览器
   - 如果 Proxy 不可用，会通过记录 window 上的全局变量快照来模拟隔离。
3. 微调 this、eval 等特殊行为
   - 确保子应用在沙箱里执行时，this、globalThis 都指向 Proxy。
