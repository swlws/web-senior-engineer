# 乾坤的实现原理

qiankun（乾坤）的实现原理可以分成 三大核心机制：路由劫持、动态加载、沙箱隔离。它本质上是基于 single-spa 做了增强，支持样式隔离、JS 沙箱、资源预加载等。

## 1. 路由劫持 — 决定什么时候加载哪个子应用

- qiankun 会在主应用启动时注册所有子应用信息（registerMicroApps）。
- 通过 hash 路由 或 history 路由 监听 URL 变化（popstate、hashchange）。
- 匹配到对应子应用的 activeRule（激活规则）时：
  - 如果是第一次访问 → 动态加载子应用资源（HTML、CSS、JS）
  - 如果访问过 → 从缓存中直接激活

## 2. 动态加载子应用 — HTML Entry 解析与执行

qiankun 默认用 HTML Entry 模式 加载子应用：

1. 获取子应用入口 HTML（fetch）
2. 解析 HTML 中的 <link>、<script>、<style> 标签
3. 下载并注入这些资源到主应用的 DOM 中
4. 在执行子应用 JS 时，会传入生命周期钩子（bootstrap、mount、unmount）
5. 子应用在 mount 时渲染到主应用指定的容器（container）中

## 3. 沙箱隔离 — 避免不同子应用互相污染

qiankun 提供 两种隔离手段：

### （1）JavaScript 沙箱

- Proxy 沙箱（现代浏览器）
  - 用 new Proxy(window, handler) 拦截子应用访问全局变量
  - 让子应用的修改只作用在沙箱对象，不污染主应用或其他子应用
- 快照沙箱（旧浏览器）
  - 激活子应用时记录 window 上的全局变量快照
  - 卸载时恢复快照，撤销对子应用期间的修改

### （2）样式隔离

- Scoped CSS（运行时重写选择器）
  - 在 CSS 选择器前加唯一前缀，保证样式只作用于当前子应用容器
- Shadow DOM（可选）
  - 利用浏览器原生 Shadow DOM 隔离样式，但兼容性有限

## 4. 预加载优化

qiankun 会在主应用空闲时（requestIdleCallback）预取其他子应用的静态资源，等真正进入时几乎秒开。

## 5. 运行流程图（简化版）

```text
[URL 变化]
   ↓
[匹配 activeRule]
   ↓
[加载子应用 HTML]
   ↓
[解析并加载 CSS/JS]
   ↓
[执行 JS（在沙箱中）]
   ↓
[调用 bootstrap → mount 生命周期]
   ↓
[渲染到 container]
```

## 6. 核心优缺点

- 优点
  - 支持不同框架共存（Vue、React、Angular 都能接）
  - 样式隔离 + JS 沙箱 → 污染风险低
  - 资源按需加载 + 预加载优化
  - 生命周期清晰，子应用可独立开发部署
- 缺点
  - HTML Entry 动态加载有额外网络开销
  - 沙箱有一定性能消耗
  - 样式隔离不如 Shadow DOM 完全彻底（Scoped CSS 基于字符串重写）
