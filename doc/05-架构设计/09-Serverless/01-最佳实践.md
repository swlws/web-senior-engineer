# 最佳实践

从整体架构 → 部署方案 → 前端集成 → 实践案例四个角度出发。

## 🏗️ 一、整体架构思路

传统前端项目往往要配一台服务器：

```bash
[ 前端静态资源 ] + [ Node/Express API 服务 ] + [ 数据库 ]
```

而在 Serverless 架构 下，演变成：

```bash
[ 前端静态资源（CDN托管） ] + [ Serverless Functions（动态逻辑） ] + [ BaaS 后端服务 ]
```

### 📦 职责划分

- 前端应用（Vue / React）：纯静态文件（HTML、CSS、JS），构建后托管在 CDN 上（如 Vercel、Netlify、Cloudflare Pages）。
- Serverless Functions：处理动态接口逻辑（例如登录校验、支付回调、文件上传）。
- BaaS 服务：由云平台提供的数据库、认证、文件存储（如 Firebase、Supabase、LeanCloud）。

## ⚙️ 二、常见部署方式

| 部署平台                       | 适用场景                  | 特点                                                |
| ------------------------------ | ------------------------- | --------------------------------------------------- |
| **Vercel**                     | Next.js / React / Vue SPA | 极简部署、一键绑定 Git、自动构建函数（`api/*`）     |
| **Netlify**                    | Vue / React / Svelte      | 可配置构建命令与 Functions（`netlify/functions/*`） |
| **Cloudflare Pages + Workers** | 前后端一体 Edge 计算      | 极速响应、边缘部署                                  |
| **阿里云 FC + OSS + CDN**      | 企业级前端项目            | 国内访问快、适合和 API 网关集成                     |
| **腾讯云 SCF + COS**           | 小程序/公众号生态         | 对微信体系集成好                                    |

## 🧩 三、前端结合方式

### 1. 单仓一体化模式

前端和函数在同一项目仓库中，例如 Vercel / Netlify 默认结构：

```bash
my-app/
├─ src/               # Vue/React 前端代码
├─ api/               # Serverless 函数
│  ├─ getUser.js
│  └─ sendMail.js
└─ vercel.json
```

调用方式:

```js
// 前端请求
fetch("/api/getUser?id=123")
  .then((res) => res.json())
  .then((data) => console.log(data));
```

Vercel 自动将 `/api/*` 映射为 Serverless Function。

### 2. 前后端分仓模式

适合大型项目或多团队协作：

- 前端仓库：打包静态资源 → CDN（Vercel、OSS）
- Serverless 仓库：函数逻辑 → 云平台部署（AWS Lambda / 阿里云 FC）

前端通过配置环境变量访问：

```js
const API_BASE = import.meta.env.VITE_API_URL;
fetch(`${API_BASE}/getUser`);
```

### 3. 使用 BaaS（省略后端）

前端直接调用云服务提供的 SDK：

- 🔥 Firebase / Supabase / Appwrite
- 💾 提供数据库、文件存储、认证
- 🧩 可完全前端化开发，无需写函数逻辑

例如使用 Supabase：

```js
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
const { data, error } = await supabase.from("users").select("*");
```

## 🧠 四、实践案例示例

### 案例 1：Vue + Vercel

```bash
npm create vue@latest my-app
cd my-app
npm install
```

新建 `/api/sendMail.js`

```js
export default async (req, res) => {
  const body = await req.json();
  // 假设使用第三方服务发送邮件
  await sendEmail(body.email, body.message);
  res.status(200).json({ ok: true });
};
```

部署到 Vercel 后：

- Vue 前端 → 静态托管
- /api/sendMail → 自动 Serverless Function

### 案例 2：React + Netlify Functions

目录：

```bash
my-app/
├─ src/
├─ netlify/
│  └─ functions/
│      └─ getUser.js
└─ netlify.toml
```

netlify/functions/getUser.js

```bash
exports.handler = async (event, context) => {
  return {
    statusCode: 200,
    body: JSON.stringify({ user: 'wenlong' })
  };
};
```

前端：

```js
fetch("/.netlify/functions/getUser")
  .then((res) => res.json())
  .then(console.log);
```

部署命令：

```bash
netlify deploy --prod
```

## 💰 五、成本与性能建议

| 建议                             | 原因                         |
| -------------------------------- | ---------------------------- |
| ✅ 函数粒度小，职责单一          | 提升冷启动性能               |
| ✅ 使用边缘函数（Edge Function） | 响应更快                     |
| ✅ 静态文件托管 CDN              | 最大化缓存命中率             |
| ✅ 将数据库连接或认证交给 BaaS   | 避免状态丢失                 |
| ⚠️ 控制函数冷启动                | 避免依赖大包、减少初始化逻辑 |

## 🚀 六、组合式架构推荐

适合现代前端团队的组合：

| 功能     | 推荐方案                                   |
| -------- | ------------------------------------------ |
| 静态托管 | Vercel / Netlify / Cloudflare Pages        |
| 动态逻辑 | Vercel Functions / Cloudflare Workers      |
| 数据存储 | Supabase / Firebase / Prisma + PlanetScale |
| 认证     | Clerk / Supabase Auth / Auth0              |
| 日志监控 | Logtail / Sentry / Datadog                 |
