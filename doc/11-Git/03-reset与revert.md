# reset 与 revert

## 🧠 核心

| 命令             | 本质作用                                            | 是否改写历史 |
| ---------------- | --------------------------------------------------- | ------------ |
| **`git reset`**  | **移动 HEAD 指针** 到某个 commit（可修改历史）      | ✅ 是        |
| **`git revert`** | **创建一个新的反向提交** 来“撤销”旧提交（保留历史） | ❌ 否        |

## 🎯 二、核心概念对比

| 特性               | `git reset`                | `git revert`                   |
| ------------------ | -------------------------- | ------------------------------ |
| 操作对象           | 分支指针（HEAD）           | 提交内容                       |
| 是否生成新 commit  | 否（只是移动 HEAD）        | ✅ 是（会创建一个新的 commit） |
| 是否改写历史       | ✅ 是（改变提交链）        | ❌ 否（追加新提交）            |
| 是否可推送远程     | ⚠️ 需 `--force`            | ✅ 可直接推                    |
| 是否保留被撤销提交 | ❌ 会消失（除非在 reflog） | ✅ 保留在历史中                |
| 场景               | 撤回最近提交、重写历史     | 回滚线上错误提交、团队协作     |
| 是否危险           | ⚠️ 是（可能丢改动）        | ✅ 安全                        |

## 📜 三、直观例子

假设当前历史如下：

```bash
A --- B --- C --- D   ← main
```

### 🧩 1️⃣ 使用 git reset

#### （1）回退到 B

```bash
git reset --hard B
```

结果：

```bash
A --- B   ← main
```

- C、D 被“丢弃”（HEAD 和分支指针回到了 B）
- 如果没推送过还好；
  若推送过，再 push --force 会覆盖远程！

#### （2）--soft 模式：只回退提交，不丢代码

```bash
git reset --soft B
```

结果：

- HEAD → B
- 工作区、暂存区仍包含 C、D 的改动
- 你可以重新提交一次

#### （3）--mixed 模式（默认）

```bash
git reset B
```

结果：

- 清空暂存区（git add 的内容会被还原）
- 但工作区文件保留

### 🧩 2️⃣ 使用 git revert

撤销 C 的提交：

```bash
git revert C
```

结果：

```bash
A --- B --- C --- D --- E
```

其中 E 是新生成的 commit，它的内容 = “反做 C 的修改”。

- 历史未变，C 仍存在。
- E 是安全的“反向提交”。
- 可以直接 git push。

## 🧭 四、对比可视化

操作前

```bash
A --- B --- C --- D   ← main
```

reset（回退历史）

```bash
A --- B   ← main
```

revert（新增反向提交）

```bash
A --- B --- C --- D --- E   ← main
             ↑ 撤销 C
```

## ⚙️ 五、使用场景总结

| 场景                       | 推荐命令                       | 说明                              |
| -------------------------- | ------------------------------ | --------------------------------- |
| **刚刚提交错了，还没推送** | `git reset --soft HEAD~1`      | 回退到上一个提交，保留代码        |
| **想删除最近几次提交**     | `git reset --hard HEAD~3`      | 回退历史（危险）                  |
| **需要撤销线上提交**       | `git revert <commit>`          | 新建反向提交，安全                |
| **多人协作项目**           | `git revert`                   | 永远不要用 reset 改别人依赖的历史 |
| **个人分支重构提交历史**   | `git reset` 或 `git rebase -i` | 改写自己的历史 OK                 |

## 💣 六、组合示例

### 示例 1：撤销错误提交但保留文件修改

```bash
git reset --soft HEAD~1
```

→ 相当于取消上次提交，但文件内容还在，可重新 git commit。

### 示例 2：在远程已推送后，安全撤销

```bash
git revert <commit_hash>
git push origin main
```

## 🧠 七、经验法则

| 目标                          | 用法                      |
| ----------------------------- | ------------------------- |
| “我不想让别人知道我犯错”      | `git reset`（改写历史）   |
| “我要公开撤销这个错误”        | `git revert`（可审计）    |
| “我刚 commit 错了，还没 push” | `git reset --soft HEAD~1` |
| “我 push 错了，还得修复远程”  | `git revert <commit>`     |

## 💡 八、实践建议

- 对 公共分支（如 main、develop） 👉 用 revert
- 对 个人分支或临时分支 👉 可用 reset
- 若要 清理历史记录 👉 用 rebase -i
- 若要 完全丢弃本地改动 👉 git reset --hard

## ✅ 小结图表

| 比较项               | `git reset`           | `git revert`     |
| -------------------- | --------------------- | ---------------- |
| 操作目标             | 移动 HEAD（重写历史） | 生成反向提交     |
| 是否创建新 commit    | 否                    | 是               |
| 是否影响历史         | 是                    | 否               |
| 可否安全推送         | 否（需强推）          | 是               |
| 常见用途             | 撤销未推送的提交      | 撤销已推送的提交 |
| 是否保留原 commit    | 否                    | 是               |
| 是否推荐用于公共分支 | 否                    | ✅ 是            |
