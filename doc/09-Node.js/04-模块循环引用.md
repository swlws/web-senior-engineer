# 模块循环引用

Node.js 的模块循环引用（circular dependency）是 require 加载机制里经常踩的坑。

## 1. 循环引用产生的原因

Node.js 使用 CommonJS 规范，require 的加载过程是：

1. 解析模块路径 → 定位文件
2. 判断是否在 require.cache 中
   - ✅ 在缓存里 → 直接返回缓存
   - ❌ 不在 → 初始化一个空的 Module 对象并放入缓存
3. 执行模块代码，填充 module.exports

关键点：

> 在执行过程中，模块就已经加入缓存，所以如果 A require B，而 B 又 require A，第二次 require 时会直接返回 未执行完成的半成品 exports 对象。

## 2. 代码示例

a.js

```js
console.log("a.js start");
exports.done = false;
const b = require("./b");
console.log("in a.js, b.done =", b.done);
exports.done = true;
console.log("a.js end");
```

b.js

```js
console.log("b.js start");
exports.done = false;
const a = require("./a");
console.log("in b.js, a.done =", a.done);
exports.done = true;
console.log("b.js end");
```

main.js

```js
require("./a");
```

运行结果

```txt
a.js start
b.js start
in b.js, a.done = false   <-- ⚠️ a 还没执行完
b.js end
in a.js, b.done = true
a.js end
```

可以看到：

- 当 b.js require a.js 时，a.js 还没跑完，exports.done 还是初始值 false。
- 所以拿到的是 部分初始化的模块对象。

## 3. 解决方案

循环依赖本质上是设计问题，但 Node 给了几种常见的解决思路：

### ✅ 方案 1：重构依赖关系

把 公共逻辑抽离到第三个模块 C，A 和 B 都依赖 C，而不是相互依赖。

```txt
A → C ← B
```

### ✅ 方案 2：延迟 require

在需要时再加载，而不是模块初始化时：

```js
function getB() {
  return require("./b");
}
```

这样等 a.js 完全执行完毕后，再去加载 b.js。

### ✅ 方案 3：使用函数调用而不是直接导出对象

不要在模块加载时直接执行逻辑，改为导出函数，在调用函数时再获取依赖：

```js
// a.js
exports.getData = () => {
  const b = require("./b");
  return "A + " + b.getData();
};
```

### ✅ 方案 4：ESM（import/export）

在 ES Module 里，循环依赖不会返回半成品对象，而是绑定到 live binding（活引用），一定程度上更安全。但依赖初始化顺序还是需要注意。

## 4. 总结

- Node.js 循环引用时，返回的可能是 未完成初始化的 exports。
- 常见问题是拿到 空对象 或 不完整数据。
- 解决思路：抽公共模块 / 延迟 require / 函数封装 / 改用 ESM。
