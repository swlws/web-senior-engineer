# Vue2 双向绑定

## 🚀 一、什么是双向绑定

双向绑定（Two-way Binding）是指：

> 当数据变化时，视图自动更新；
> 当用户修改视图时，数据也自动变化。

即「数据驱动视图，视图反过来更新数据」。

在 Vue 中，就是通过 v-model 实现的：

```html
<input v-model="message" />
<p>{{ message }}</p>
```

当你输入内容时：

- message 会被更新；
- 模板中 {{ message }} 也会重新渲染。

## ⚙️ 二、Vue 2 双向绑定的核心：Object.defineProperty

Vue 2 使用 Object.defineProperty 来拦截数据的「读写访问」，从而实现响应式。

核心思想：

> 给每个数据属性设置 getter / setter，拦截读取和修改操作。

### ✅ 简化示例

```js
function defineReactive(obj, key, val) {
  const dep = new Dep(); // 依赖收集器

  Object.defineProperty(obj, key, {
    get() {
      dep.depend(); // 收集依赖（谁在用这个值）
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify(); // 通知依赖更新
      }
    },
  });
}
```

当组件渲染时：

- Vue 会执行 getter → 收集依赖；
- 当数据变化时 → 执行 setter → 通知更新。

## 🧩 三、响应式核心模块结构

Vue 2 响应式系统由以下几部分组成：

| 模块                   | 作用                                   |
| ---------------------- | -------------------------------------- |
| **Observer**           | 遍历对象，给每个属性加 getter/setter   |
| **Dep（依赖管理器）**  | 收集 watcher 依赖，并在更新时通知      |
| **Watcher（订阅者）**  | 代表具体的渲染或计算逻辑               |
| **Compiler（编译器）** | 解析模板，生成渲染函数，绑定数据和 DOM |

**📊 流程图（简化）**

```txt
数据变化 → setter → Dep.notify()
          ↓
       Watcher 更新
          ↓
     Virtual DOM diff
          ↓
        视图更新
```

## 🧠 四、具体运行流程（以 v-model 为例）

假设你有：

```html
<input v-model="msg" />
<p>{{ msg }}</p>
```

Vue 会做以下几件事：

1. 初始化响应式：
   - 给 data.msg 设置 getter/setter；
   - Observer 会为每个属性创建 Dep 管理依赖。
2. 编译模板：
   - v-model 被编译成：
   ```html
   <input :value="msg" @input="msg = $event.target.value" />
   ```
   - 绑定输入事件，实现反向更新。
3. 依赖收集：
   - 当渲染 {{ msg }} 时，触发 getter；
   - 当前渲染函数对应的 Watcher 被加入 Dep 的依赖列表。
4. 更新流程：
   - 用户输入 → 触发 setter → 通知 Dep；
   - Dep.notify() 通知相关 Watcher；
   - Watcher 触发重新渲染；
   - DOM 更新完成。

## 🧮 五、核心类简化实现

```js
// ----------------------
// 依赖收集器 Dep
// ----------------------
class Dep {
  constructor() {
    this.subs = new Set(); // 订阅者集合
  }
  depend() {
    if (Dep.target) {
      this.subs.add(Dep.target);
    }
  }
  notify() {
    this.subs.forEach((sub) => sub.update());
  }
}

// 当前全局正在执行的 watcher
Dep.target = null;

// ----------------------
// 观察者 Watcher
// ----------------------
class Watcher {
  constructor(obj, key, cb) {
    this.obj = obj;
    this.key = key;
    this.cb = cb;
    this.value = this.get(); // 触发依赖收集
  }
  get() {
    Dep.target = this; // 设置全局依赖目标
    const value = this.obj[this.key]; // 触发 getter 收集依赖
    Dep.target = null; // 收集完毕后清空
    return value;
  }
  update() {
    const newVal = this.obj[this.key];
    if (newVal !== this.value) {
      this.value = newVal;
      this.cb(newVal);
    }
  }
}

// ----------------------
// 响应式定义 defineReactive
// ----------------------
function defineReactive(obj, key, val) {
  const dep = new Dep();

  Object.defineProperty(obj, key, {
    get() {
      dep.depend(); // 收集依赖
      return val;
    },
    set(newVal) {
      if (newVal !== val) {
        val = newVal;
        dep.notify(); // 通知更新
      }
    },
  });
}

// ----------------------
// 劫持整个对象 observe
// ----------------------
function observe(obj) {
  Object.keys(obj).forEach((key) => defineReactive(obj, key, obj[key]));
}

// ----------------------
// 测试示例
// ----------------------
const state = { count: 1, msg: "hello" };
observe(state);

// 创建一个 watcher，依赖 state.count
new Watcher(state, "count", (newVal) => {
  console.log("count 变化了:", newVal);
});

// 修改数据，触发更新
state.count = 2;
state.count = 3;
state.msg = "world"; // 不影响 count 的 watcher
```

输出：

```text
count 变化了: 2
count 变化了: 3

```

## ⚡ 六、Vue 2 响应式的局限性

由于使用 Object.defineProperty：

- 无法监听 对象新增/删除属性；
- 无法监听 数组下标修改；
- 无法深度代理嵌套结构；
- 所以需要用 $set、$delete 这类 API。

例如：

```js
vm.obj.newProp = 1; // ❌ 不响应
Vue.set(vm.obj, "newProp", 1); // ✅ 响应式
```

## 🧩 七、Vue 3 的改进（对比 Vue 2）

| 特性       | Vue 2                   | Vue 3               |
| ---------- | ----------------------- | ------------------- |
| 响应式实现 | `Object.defineProperty` | `Proxy`             |
| 监听能力   | 只能劫持已存在属性      | 可监听新增/删除属性 |
| 性能       | 初始化时递归遍历对象    | 懒代理（按需）      |
| 数组       | 手动重写部分方法        | 全面代理            |
| 源码复杂度 | 高                      | 更简洁              |
| 兼容性     | ES5                     | 需要 ES6 Proxy 支持 |

## ✅ 八、总结一句话

Vue 2 的双向绑定本质是基于 Object.defineProperty + 发布订阅模式 的响应式系统。
它通过 getter 收集依赖、setter 派发更新 实现「数据驱动视图」，
再通过 v-model 实现「视图反向更新数据」。
