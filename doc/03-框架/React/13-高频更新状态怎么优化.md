# 高频次的更新状态怎么优化？

优化思路主要是 **减少不必要渲染**、**降低更新频率**、以及 **延迟或批量处理更新**。

## 1️⃣ 避免不必要的渲染

- React.memo / PureComponent
  - 对函数组件用 React.memo(Component)，仅当 props 变化时才重新渲染。
  - 类组件用 PureComponent，自动浅比较 props 和 state。
- useMemo / useCallback
  - 避免函数或对象在每次渲染中被重新创建，导致子组件触发渲染。
  ```jsx
  const handleClick = useCallback(() => { ... }, [deps])
  const computedValue = useMemo(() => computeHeavy(value), [value])
  ```
- 拆分组件
  - 将大组件拆成多个小组件，只更新需要更新的部分。

## 2️⃣ 降低状态更新频率

- 节流（throttle）/ 防抖（debounce）
  - 高频事件（如滚动、输入、鼠标移动）更新 state 前进行节流或防抖。
  ```jsx
  const [pos, setPos] = useState({ x: 0, y: 0 });
  const handleMouseMove = throttle((e) => {
    setPos({ x: e.clientX, y: e.clientY });
  }, 50);
  ```
  - 节流可以保证每 50ms 更新一次状态，而不是每个事件都更新。
- 批量更新 - React 18 默认批量更新，但在某些异步场景中仍然需要手动合并多次状态：
  ```jsx
  setCount((c) => c + 1);
  setFlag((f) => !f); // 会合并成一次渲染
  ```

## 3️⃣ 使用 Ref 或外部状态管理避免频繁触发渲染

- 对于 频繁变化但不影响渲染的值，可以使用 useRef：
  ```jsx
  const posRef = useRef({ x: 0, y: 0 });
  const handleMouseMove = (e) => {
    posRef.current = { x: e.clientX, y: e.clientY }; // 不触发渲染
  };
  ```
- 对于全局高频数据，可以使用 zustand / Jotai / recoil 等状态管理库，并结合选择器优化局部订阅。

## 4️⃣ 异步渲染优化

- useTransition（React 18+）
  - 对非紧急状态更新标记为“低优先级”，不会阻塞用户交互：
    ```jsx
    const [isPending, startTransition] = useTransition();
    startTransition(() => setList(newList));
    ```
- 虚拟化列表
  - 对大量元素渲染只渲染可视区域（如 react-window, react-virtualized）。

## 5️⃣ 其他注意点

- 避免在 render 或 useEffect 中做 频繁的对象/数组创建，尽量复用。
- 对复杂计算的 state 使用 惰性初始化：

```jsx
const [data, setData] = useState(() => computeInitialData());
```

## 💡 总结：

高频状态更新核心策略是 **减少渲染次数** + **降低更新频率** + **优化渲染成本**。
