# 尾调用

尾调用（Tail Call）是函数式编程里的一个概念，JavaScript（尤其 ES6）也有相关支持。

## 定义

尾调用：在函数的最后一步调用另一个函数（或自己）。

> “最后一步” 的意思是 返回调用结果，不再对结果做任何额外操作。

✅ 属于尾调用的例子：

```js
function f(x) {
  return g(x); // g(x) 的返回值直接返回给 f
}
```

❌ 不是尾调用的例子：

```js
function f(x) {
  return g(x) + 1; // 调用 g(x) 后还要做 +1 运算
}
```

## 2. 尾调用优化（Tail Call Optimization, TCO）

尾调用优化指的是：
当一个函数在尾部调用自身（或其他函数），解释器可以复用当前的栈帧，而不是新建一个。
这样可以避免栈空间无限增长，从而防止栈溢出。

### 示例：普通递归（会爆栈）

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1); // 非尾调用，因为还要做乘法
}
console.log(factorial(100000)); // 很可能栈溢出
```

### 示例：尾递归（理论上可优化）

```js
function factorial(n, acc = 1) {
  if (n === 1) return acc;
  return factorial(n - 1, acc * n); // 尾调用：直接返回递归结果
}
console.log(factorial(100000)); // 理论上可以避免栈溢出
```

## 3. JavaScript 的现状

- ES6 规范：要求实现对尾调用的优化。
- 实际情况：
  - Safari（早期版本）支持过 TCO。
  - 但 V8（Chrome/Node.js）、SpiderMonkey（Firefox）都没有实现，主要因为调试体验差（调用栈信息会丢失）。
- 所以在 现代 JavaScript 中，尾调用优化几乎不可用，尾递归仍会导致栈溢出。

## 4. 解决办法

在 JS 中若要避免栈溢出，常用两种手段：

### （1）改写为循环

```js
function factorial(n) {
  let result = 1;
  while (n > 1) {
    result *= n;
    n--;
  }
  return result;
}
```

### （2）Trampoline 技术（蹦床函数）

把递归改写成“返回函数”的形式，用一个 while 循环展开：

```js
function trampoline(f) {
  while (typeof f === "function") {
    f = f();
  }
  return f;
}

function factorial(n, acc = 1) {
  if (n === 1) return acc;
  return () => factorial(n - 1, acc * n);
}

console.log(trampoline(factorial(100000)));
```

## 5. 总结

- 尾调用 = 最后一步直接调用另一个函数。
- 尾调用优化 = 复用栈帧，避免栈溢出。
- JavaScript 规范支持，但实现很少（实际不可依赖）。
- 工程上要么改成循环，要么用 trampoline 技术模拟。
