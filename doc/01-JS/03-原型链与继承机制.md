# 原型链与继承机制

## 1. 原型链

### 1.1 原型对象

每个函数都有一个 `prototype` 属性，这个属性指向一个对象，称为**原型对象**
创建对象时，会自动创建原型对象，原型对象会自动继承 `Object.prototype`，原型对象本身是一个普通对象，可以添加属性和方法。

### 1.2 原型链

对象的 `__proto__` 属性指向它的原型对象，原型对象的 `__proto__` 指向它的原型对象，以此类推，形成了一个原型链。

### 1.3 原型链的查找

1. 创建对象时，会自动创建原型对象，原型对象会自动继承 `Object.prototype`。
2. 对象的 `__proto__` 属性指向它的原型对象，原型对象的 `__proto__` 指向它的原型对象，以此类推，形成了一个原型链。
3. 当访问一个对象的属性时，会先在对象自身查找，如果没有找到，会在原型链中查找，直到找到为止。
4. 如果原型链中没有找到，会返回 `undefined`。

### 1.4 原型链的作用

1. 继承属性和方法
2. 实现多态

### 1.5 原型链的注意事项

1. 原型链的查找是从上到下的，所以如果原型链中存在同名属性，会覆盖前面的属性。

## 2. 继承机制

### 2.1 原型继承

1. 原型继承是通过原型链实现的，每个函数都有一个 `prototype` 属性，这个属性指向一个对象，称为**原型对象**。
2. 原型对象会自动继承 `Object.prototype`，原型对象本身是一个普通对象，可以添加属性和方法。
3. 当创建一个对象时，会自动创建原型对象，原型对象会自动继承 `Object.prototype`。
4. 对象的 `__proto__` 属性指向它的原型对象，原型对象的 `__proto__` 指向它的原型对象，以此类推，形成了一个原型链。
5. 通过原型链，对象可以访问原型对象中的属性和方法。

### 2.2 构造函数继承

1. 构造函数继承是通过 `call` 或 `apply` 方法调用父类的构造函数来实现的。
2. 父类的构造函数会执行，会将 `this` 指向子类的实例。
3. 子类的实例可以访问父类的属性和方法。

### 2.3 组合继承

1. 组合继承是通过原型继承和构造函数继承结合起来实现的。
2. 子类的原型对象会继承父类的原型对象，子类的实例会继承父类的属性和方法。
3. 子类的构造函数会执行，会将 `this` 指向子类的实例。

### 2.4 原型式继承

1. 原型式继承是通过 `Object.create` 方法实现的。
2. `Object.create` 方法会创建一个新对象，新对象的 `__proto__` 属性指向传入的对象。
3. 新对象可以访问传入对象的属性和方法。

### 2.5 寄生式继承

1. 寄生式继承是通过原型式继承和构造函数继承结合起来实现的。
2. 寄生式继承会创建一个新对象，新对象的 `__proto__` 属性指向传入的对象。
3. 新对象可以访问传入对象的属性和方法。
4. 新对象可以添加属性和方法。

### 2.6 寄生组合式继承

1. 寄生组合式继承是通过原型式继承和构造函数继承结合起来实现的。
2. 寄生组合式继承会创建一个新对象，新对象的 `__proto__` 属性指向传入的对象的原型对象。
3. 新对象可以访问传入对象的属性和方法。
4. 新对象可以添加属性和方法。

### 2.7 继承的注意事项

1. 继承是一种面向对象编程的概念，它可以让一个对象继承另一个对象的属性和方法。
2. 继承可以让我们避免重复编写代码，提高代码的复用性。
3. 继承可以让我们更加方便地管理代码，提高代码的可读性和可维护性。

---

## 继承的多种实现

### 1. 原型链继承

```js
function Parent() {
  this.colors = ["red", "green"];
}
Parent.prototype.say = function () {
  console.log("hello");
};

function Child() {}
Child.prototype = new Parent(); // 核心
Child.prototype.constructor = Child;

const c1 = new Child();
c1.colors.push("blue");

const c2 = new Child();
console.log(c2.colors); // ['red','green','blue'] ❌ 被污染
```

✅ 优点：方法复用（子类可访问父类原型上的方法）
❌ 缺点：引用类型属性被所有实例共享；无法传参给父类构造函数

### 2. 借用构造函数继承（经典继承）

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "green"];
}

function Child(name, age) {
  Parent.call(this, name); // 借用父构造函数
  this.age = age;
}

const c1 = new Child("Alice", 20);
const c2 = new Child("Bob", 22);
c1.colors.push("blue");
console.log(c2.colors); // ['red','green'] ✅ 独立
```

- ✅ 优点：
  - 解决了引用类型属性被所有实例共享的问题；
  - 实例属性独立（不会共享引用类型）,可以传参给父类构造函数
- ❌ 缺点：方法不能复用（子类不能访问父类原型上的方法）

### 3. 组合继承（原型链继承 + 借用构造函数继承）

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "green"];
}
Parent.prototype.sayName = function () {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}

Child.prototype = new Parent(); // 继承方法
Child.prototype.constructor = Child;

const c1 = new Child("Alice", 20);
c1.sayName();
```

✅ 优点：实例属性独立，方法复用
❌ 缺点：Parent 构造函数执行了两次（一次在 call，一次在 new Parent()），多余属性挂到 prototype 上

### 4. 原型式继承

```js
function createObj(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

const parent = { colors: ["red", "green"] };
const child = createObj(parent);

child.colors.push("blue");
console.log(parent.colors); // ['red','green','blue'] ❌ 共享
```

✅ 优点：简单，类似 Object.create 的 polyfill
❌ 缺点：和原型链继承一样，引用类型共享

### 5. 寄生式继承

```js
function createChild(o) {
  const clone = Object.create(o); // 原型式继承
  clone.sayHi = function () {
    console.log("hi");
  };
  return clone;
}

const parent = { name: "Alice" };
const child = createChild(parent);
child.sayHi();
```

✅ 优点：在原型式继承的基础上，增强对象
❌ 缺点：方法没有复用（每次都新建一份，和构造函数继承类似）

### 6. 寄生组合继承（最优解）

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "green"];
}
Parent.prototype.sayName = function () {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 继承实例属性
  this.age = age;
}

// 关键：只继承一次
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

Child.prototype.sayAge = function () {
  console.log(this.age);
};
```

✅ 优点：实例属性独立，方法复用，父类构造函数只执行一次（完美优化组合继承）
❌ 缺点：写法稍微繁琐

👉 ES6 的 class extends 就是寄生组合继承的语法糖。

### 7. ES6 class 继承

```js
class Parent {
  constructor(name) {
    this.name = name;
    this.colors = ["red", "green"];
  }
  sayName() {
    console.log(this.name);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name); // 等价于 Parent.call(this, name)
    this.age = age;
  }
  sayAge() {
    console.log(this.age);
  }
}
```

✅ 优点：语法简洁，接近传统 OOP；底层就是寄生组合继承
❌ 缺点：本质还是语法糖；对某些底层细节（比如原型链）不透明

## 📊 总结对比表

| 继承方式         | 方法复用 | 实例属性独立 | 父构造函数调用次数 | 能否传参 | 缺点           |
| ---------------- | -------- | ------------ | ------------------ | -------- | -------------- |
| 原型链继承       | ✅       | ❌           | 1                  | ❌       | 引用属性共享   |
| 借用构造函数继承 | ❌       | ✅           | 1                  | ✅       | 方法不能复用   |
| 组合继承         | ✅       | ✅           | 2                  | ✅       | 父类执行两次   |
| 原型式继承       | ✅       | ❌           | 1                  | ❌       | 引用属性共享   |
| 寄生式继承       | ❌       | ❌           | 1                  | ❌       | 方法无法复用   |
| 寄生组合继承     | ✅       | ✅           | 1                  | ✅       | 写法复杂       |
| ES6 class        | ✅       | ✅           | 1                  | ✅       | 语法糖，限制多 |
